<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1a1f3a">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ translations.title }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --midnight-blue: #1a1f3a;
            --charcoal: #2c3e50;
            --slate: #34495e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --text-light: #ecf0f1;
            --text-dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--midnight-blue) 0%, var(--charcoal) 100%);
            color: var(--text-light);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* Header */
        header {
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        .nav-links {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .donate-btn {
            background: var(--success);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .donate-btn:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }
        
        .lang-selector {
            display: flex;
            gap: 0.5rem;
        }
        
        .lang-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .lang-btn:hover, .lang-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        /* Main Content */
        main {
            padding: 2rem 0;
        }
        
        .hero {
            text-align: center;
            padding: 3rem 0;
        }
        
        .hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent), #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .filters {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 2rem 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .filter-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--accent);
        }
        
        .filter-group select,
        .filter-group input {
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .showtimes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .showtime-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0;
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }
        
        .movie-image-container {
            width: 100%;
            height: 300px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .movie-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        
        .showtime-card:hover .movie-image {
            transform: scale(1.05);
        }
        
        .movie-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--charcoal), var(--slate));
            color: var(--text-light);
            font-size: 3rem;
            opacity: 0.5;
        }
        
        .showtime-card-content {
            padding: 1.5rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card h3 {
            color: var(--accent);
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
        }
        
        .showtime-card .time {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0.5rem 0;
            color: var(--text-light);
        }
        
        .showtime-card .cinema {
            color: var(--text-light);
            margin-bottom: 0.5rem;
        }
        
        .showtime-card .cinema-name {
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }
        
        .showtime-card .cinema-address {
            font-size: 0.9rem;
            opacity: 0.9;
            color: var(--text-light);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .buy-btn {
            display: inline-block;
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }
        
        .buy-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.02);
        }
        
        .city-input-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .city-input-group input {
            flex: 1;
        }
        
        .search-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .search-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        .location-input-group {
            position: relative;
        }
        
        .location-input-group input {
            width: 100%;
        }
        
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .suggestions-dropdown.show {
            display: block;
        }
        
        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .suggestion-item:hover,
        .suggestion-item.selected {
            background: var(--accent);
        }
        
        .suggestion-item.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item small {
            opacity: 0.7;
        }
        
        /* Footer */
        footer {
            background: rgba(26, 31, 58, 0.95);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
        }
        
        .visitor-counter {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 1.5rem;
        }
        
        /* Full-page loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.show {
            opacity: 1;
        }
        
        .loading-overlay-content {
            text-align: center;
            color: white;
        }
        
        .loading-overlay .spinner-glow {
            margin: 0 auto 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Center the movie icon inside spinner */
        .loading-overlay .spinner-glow > * {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
            margin: 0;
        }
        
        .loading-overlay .loading-text {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .loading-overlay p {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 0.5rem;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }
        
        /* Loading Skeleton */
        .loading-skeleton {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .skeleton-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            animation: skeleton-pulse 1.5s ease-in-out infinite;
        }
        
        .skeleton-image {
            width: 100%;
            height: 300px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .skeleton-content {
            padding: 1.5rem;
        }
        
        .skeleton-line {
            height: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 0.75rem;
        }
        
        .skeleton-line.short {
            width: 60%;
        }
        
        .skeleton-line.medium {
            width: 80%;
        }
        
        @keyframes skeleton-pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        
        /* Spinner - Enhanced Cool Animation */
        .spinner {
            display: inline-block;
            width: 60px;
            height: 60px;
            position: relative;
            margin: 0 auto 1.5rem;
        }
        
        .spinner::before,
        .spinner::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
        }
        
        .spinner::before {
            width: 60px;
            height: 60px;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.3);
        }
        
        .spinner::after {
            width: 40px;
            height: 40px;
            top: 10px;
            left: 10px;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.3);
            animation: spin 0.8s linear infinite reverse;
        }
        
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        /* Enhanced Cool Spinner with Glow Effect */
        .spinner-glow {
            display: inline-block;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(52, 152, 219, 0.4) 0%, rgba(155, 89, 182, 0.2) 50%, transparent 70%);
            animation: pulse 2s ease-in-out infinite;
            margin: 0 auto 2rem;
            position: relative;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
        }
        
        .spinner-glow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            border: 5px solid transparent;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.4);
            border-bottom-color: rgba(52, 152, 219, 0.2);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6);
            margin: 0;
            z-index: 1;
            transform-origin: center center;
        }
        
        .spinner-glow::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 45px;
            height: 45px;
            border: 4px solid transparent;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.5);
            border-bottom-color: rgba(155, 89, 182, 0.2);
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);
            margin: 0;
            z-index: 2;
            transform-origin: center center;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
                box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.15);
                box-shadow: 0 0 40px rgba(52, 152, 219, 0.7), 0 0 80px rgba(155, 89, 182, 0.5);
            }
        }
        
        /* Movie icon animation in spinner center */
        @keyframes iconFloat {
            0%, 100% {
                transform: translate(-50%, -50%) translateY(0) rotate(0deg);
            }
            50% {
                transform: translate(-50%, -50%) translateY(-5px) rotate(5deg);
            }
        }
        
        .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
            z-index: 10;
        }
        
        /* Ensure iconFloat animation preserves centering for loading overlay */
        .loading-overlay .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
        }
        
        /* Loading text animation */
        .loading-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent);
            margin-top: 1.5rem;
            animation: fadeInOut 2s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            letter-spacing: 0.5px;
        }
        
        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0.7;
                transform: translateY(0);
            }
            50% {
                opacity: 1;
                transform: translateY(-3px);
            }
        }
        
        .loading-dots {
            display: inline-block;
            width: 1ch;
        }
        
        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% {
                content: '.';
            }
            40% {
                content: '..';
            }
            60%, 100% {
                content: '...';
            }
        }
        
        
        /* Error State */
        .error-state {
            text-align: center;
            padding: 3rem;
        }
        
        .error-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: var(--warning);
        }
        
        .error-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--warning);
        }
        
        .error-state p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .retry-btn {
            padding: 0.75rem 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .retry-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        /* Country Search Input */
        .country-input-group {
            position: relative;
        }
        
        .country-input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .country-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .country-dropdown.show {
            display: block;
        }
        
        .country-option {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .country-option:hover,
        .country-option.selected {
            background: var(--accent);
        }
        
        .country-option.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .country-option:last-child {
            border-bottom: none;
        }
        
        /* Focus States for Accessibility */
        *:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .filter-group input:focus,
        .filter-group select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .buy-btn:focus-visible,
        .search-btn:focus-visible,
        .donate-btn:focus-visible,
        .lang-btn:focus-visible,
        .retry-btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        /* Image Error Handling */
        .movie-image {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .movie-image[src=""],
        .movie-image:not([src]) {
            display: none;
        }
        
        /* Desktop Optimizations (Large Screens) */
        @media (min-width: 1200px) {
            .container {
                max-width: 1400px;
                padding: 0 40px;
            }
            
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: 2rem;
            }
            
            .filters {
                padding: 2rem;
                grid-template-columns: repeat(4, 1fr);
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 2;
            }
            
            .hero h1 {
                font-size: 3.5rem;
            }
            
            .showtime-card-content {
                padding: 2rem;
            }
        }
        
        /* Desktop (Standard) */
        @media (min-width: 1024px) and (max-width: 1199px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
            
            .filters {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 2;
            }
        }
        
        /* Tablet and Medium Screens */
        @media (min-width: 769px) and (max-width: 1023px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
            
            .filters {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }
        
        /* Mobile and Small Tablets */
        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }
            
            header {
                padding: 0.75rem 0;
            }
            
            .logo {
                font-size: 1.25rem;
            }
            
            nav {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            
            .nav-links {
                gap: 0.5rem;
            }
            
            .lang-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }
            
            .donate-btn {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }
            
            main {
                padding: 1.5rem 0;
            }
            
            .hero {
                padding: 2rem 0;
            }
            
            .hero h1 {
                font-size: 2rem;
                margin-bottom: 0.75rem;
            }
            
            .hero p {
                font-size: 1rem;
            }
            
            .filters {
                grid-template-columns: 1fr;
                padding: 1.25rem;
                gap: 1.25rem;
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 1 !important;
            }
            
            .filter-group label {
                font-size: 0.95rem;
                margin-bottom: 0.4rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.875rem;
                font-size: 1rem;
                min-height: 44px; /* Touch-friendly minimum */
            }
            
            .search-btn {
                padding: 0.875rem 1.5rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .showtimes-grid {
                grid-template-columns: 1fr;
                gap: 1.25rem;
                margin-top: 1.5rem;
            }
            
            .showtime-card {
                border-radius: 12px;
            }
            
            .showtime-card:hover {
                transform: none; /* Disable hover transform on mobile */
            }
            
            .movie-image-container {
                height: 250px;
            }
            
            .showtime-card-content {
                padding: 1.25rem;
            }
            
            .showtime-card h3 {
                font-size: 1.15rem;
            }
            
            .showtime-card .time {
                font-size: 1.1rem;
            }
            
            .buy-btn {
                padding: 0.875rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .loading-skeleton {
                grid-template-columns: 1fr;
                gap: 1.25rem;
            }
            
            .skeleton-image {
                height: 250px;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1.5rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 3rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.25rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 1rem;
            }
            
            .retry-btn {
                padding: 0.875rem 1.75rem;
                min-height: 44px;
                font-size: 1rem;
            }
            
            footer {
                padding: 1.5rem 0;
            }
            
            .visitor-counter {
                font-size: 1.1rem;
            }
        }
        
        /* Small Mobile Devices */
        @media (max-width: 480px) {
            .container {
                padding: 0 12px;
            }
            
            header {
                padding: 0.6rem 0;
            }
            
            .logo {
                font-size: 1.1rem;
            }
            
            .lang-selector {
                gap: 0.4rem;
            }
            
            .lang-btn {
                padding: 0.35rem 0.7rem;
                font-size: 0.85rem;
            }
            
            .donate-btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
            
            main {
                padding: 1rem 0;
            }
            
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
                margin-bottom: 0.5rem;
            }
            
            .hero p {
                font-size: 0.95rem;
            }
            
            .filters {
                padding: 1rem;
                gap: 1rem;
                border-radius: 8px;
            }
            
            .filter-group label {
                font-size: 0.9rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .search-btn {
                padding: 0.75rem 1.25rem;
                font-size: 0.95rem;
            }
            
            .showtimes-grid {
                gap: 1rem;
                margin-top: 1.25rem;
            }
            
            .movie-image-container {
                height: 220px;
            }
            
            .showtime-card-content {
                padding: 1rem;
            }
            
            .showtime-card h3 {
                font-size: 1.1rem;
            }
            
            .showtime-card .time {
                font-size: 1rem;
            }
            
            .showtime-card .cinema-address {
                font-size: 0.85rem;
            }
            
            .buy-btn {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .loading-skeleton {
                gap: 1rem;
            }
            
            .skeleton-image {
                height: 220px;
            }
            
            .skeleton-content {
                padding: 1rem;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 2.5rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.1rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 0.95rem;
            }
            
            .spinner {
                width: 35px;
                height: 35px;
            }
            
            footer {
                padding: 1.25rem 0;
            }
            
            .visitor-counter {
                font-size: 1rem;
            }
        }
        
        /* Very Small Mobile Devices */
        @media (max-width: 360px) {
            .hero h1 {
                font-size: 1.5rem;
            }
            
            .filters {
                padding: 0.875rem;
            }
            
            .movie-image-container {
                height: 200px;
            }
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--charcoal);
            margin: 5% auto;
            padding: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-header h2 {
            margin: 0;
            color: var(--accent);
            font-size: 1.5rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--warning);
        }
        
        .modal form {
            padding: 1.5rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent);
            font-weight: 600;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-color: var(--accent);
        }
        
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        
        .btn-cancel,
        .btn-submit {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-submit {
            background: var(--accent);
            color: white;
        }
        
        .btn-submit:hover {
            background: var(--accent-hover);
        }
        
        .btn-submit:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #feedback-message-display {
            padding: 1rem;
            border-radius: 5px;
            text-align: center;
        }
        
        #feedback-message-display.success {
            background: rgba(39, 174, 96, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        #feedback-message-display.error {
            background: rgba(243, 156, 18, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
            
            .modal-header {
                padding: 1rem;
            }
            
            .modal form {
                padding: 1rem;
            }
            
            .form-actions {
                flex-direction: column;
            }
            
            .btn-cancel,
            .btn-submit {
                width: 100%;
            }
        }
        
        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Disable hover effects on touch devices */
            .showtime-card:hover {
                transform: none;
                box-shadow: none;
            }
            
            .showtime-card:hover .movie-image {
                transform: none;
            }
            
            /* Increase touch targets */
            .lang-btn,
            .donate-btn,
            .search-btn,
            .buy-btn,
            .retry-btn {
                min-height: 44px;
            }
            
            .suggestion-item,
            .country-option {
                min-height: 44px;
                padding: 1rem 0.75rem;
            }
        }
        
        /* Desktop Hover Enhancements */
        @media (hover: hover) and (pointer: fine) {
            .showtime-card {
                cursor: pointer;
            }
            
            .suggestion-item:hover,
            .country-option:hover {
                background: var(--accent);
                transform: translateX(4px);
            }
        }
        
        /* Landscape Mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
            }
            
            .filters {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 2 !important;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav class="container">
            <a href="{{ base_path }}" style="text-decoration: none; color: inherit;"><div class="logo">CineStream</div></a>
            <div class="nav-links">
                <div class="lang-selector">
                    <a href="/set-language/en" class="lang-btn {{ 'active' if lang == 'en' else '' }}">EN</a>
                    <a href="/set-language/ua" class="lang-btn {{ 'active' if lang == 'ua' else '' }}">UA</a>
                    <a href="/set-language/ru" class="lang-btn {{ 'active' if lang == 'ru' else '' }}">RU</a>
                </div>
                <a href="{{ donation_url }}" target="_blank" class="donate-btn">üá∫üá¶ {{ translations.donate }}</a>
            </div>
        </nav>
    </header>
    
    <main class="container">
        <div class="hero">
            <h1>{{ translations.title }}</h1>
            <p>{{ translations.select_city }}</p>
        </div>
        
        <div class="filters">
            <div class="filter-group" style="grid-column: span 2;">
                <label for="city-input">{{ translations.select_city }}</label>
                <div class="location-input-group">
                    <input type="text" id="city-input" placeholder="Enter city name..." autocomplete="off" aria-label="City name input">
                    <div id="city-suggestions" class="suggestions-dropdown" role="listbox" aria-label="City suggestions"></div>
                </div>
            </div>
            
            <div class="filter-group">
                <label for="country-input">{{ translations.country or 'Country' }}</label>
                <div class="country-input-group">
                    <input type="text" id="country-input" placeholder="Search or select country..." autocomplete="off" aria-label="Country selector">
                    <div id="country-dropdown" class="country-dropdown"></div>
                </div>
                <select id="country-select" style="display: none;" aria-label="Country selector">
                    <option value="">All Countries</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label>&nbsp;</label>
                <button id="search-btn" class="search-btn" aria-label="Search for movie showtimes">üîç Search Showtimes</button>
            </div>
            
            <div class="filter-group">
                <label for="format-filter">{{ translations.filter_by_format }}</label>
                <select id="format-filter" aria-label="Filter by movie format">
                    <option value="">All Formats</option>
                    <option value="2D">2D</option>
                    <option value="3D">3D</option>
                    <option value="IMAX">IMAX</option>
                    <option value="4DX">4DX</option>
                    <option value="Dolby Atmos">Dolby Atmos</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="language-filter">{{ translations.filter_by_language }}</label>
                <select id="language-filter" aria-label="Filter by language">
                    <option value="">All Languages</option>
                    <option value="Ukrainian">Ukrainian</option>
                    <option value="English">English</option>
                    <option value="Russian">Russian</option>
                    <option value="Original">Original</option>
                </select>
            </div>
        </div>
        
        <div id="showtimes-container">
            <div class="empty-state">
                <div class="empty-state-icon">üé¨</div>
                <h3>{{ translations.select_city or 'Select a City' }}</h3>
                <p>Enter a city name and country above to find movie showtimes</p>
            </div>
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p class="visitor-counter">{{ translations.visitor_count }}: {{ visitor_count }}</p>
            <div style="margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                <a href="/terms" style="color: var(--accent); text-decoration: none;">{{ translations.terms }}</a>
                <button id="feedback-btn" style="background: none; border: none; color: var(--accent); cursor: pointer; text-decoration: underline; font-size: inherit; font-family: inherit;">{{ translations.feedback }}</button>
            </div>
            <p style="margin-top: 1rem; opacity: 0.7;">¬© 2025 CineStream. All rights reserved.</p>
        </div>
    </footer>
    
    <!-- Feedback Modal -->
    <div id="feedback-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>{{ translations.feedback }}</h2>
                <button class="modal-close" id="feedback-close">&times;</button>
            </div>
            <form id="feedback-form">
                <div class="form-group">
                    <label for="feedback-name">Name (optional)</label>
                    <input type="text" id="feedback-name" name="name" placeholder="Your name">
                </div>
                <div class="form-group">
                    <label for="feedback-email">Email (optional)</label>
                    <input type="email" id="feedback-email" name="email" placeholder="your.email@example.com">
                </div>
                <div class="form-group">
                    <label for="feedback-message">Message <span style="color: var(--warning);">*</span></label>
                    <textarea id="feedback-message" name="message" rows="6" placeholder="Your feedback, suggestions, or questions..." required></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-cancel" id="feedback-cancel">Cancel</button>
                    <button type="submit" class="btn-submit">{{ translations.send_feedback }}</button>
                </div>
                <div id="feedback-message-display" style="margin-top: 1rem; display: none;"></div>
            </form>
        </div>
    </div>
    
    <script>
        const cityInput = document.getElementById('city-input');
        const countrySelect = document.getElementById('country-select');
        const countryInput = document.getElementById('country-input');
        const countryDropdown = document.getElementById('country-dropdown');
        const citySuggestions = document.getElementById('city-suggestions');
        const searchBtn = document.getElementById('search-btn');
        const formatFilter = document.getElementById('format-filter');
        const languageFilter = document.getElementById('language-filter');
        const container = document.getElementById('showtimes-container');
        
        let currentCity = null;
        let currentCountry = null;
        let showtimes = [];
        let pollingInterval = null;
        let autocompleteTimeout = null;
        let skeletonTimeout = null;
        
        // Auto-fill city and country if detected from IP
        {% if detected_city and detected_country %}
        (function() {
            // Set city
            cityInput.value = '{{ detected_city }}';
            {% if detected_region %}
            cityInput.dataset.state = '{{ detected_region }}';
            {% endif %}
            
            // Set country
            const countryName = '{{ detected_country }}';
            countryInput.value = countryName;
            
            // Find and select the country in the dropdown
            // Try exact match first
            let countryOption = Array.from(countrySelect.options).find(opt => opt.textContent.trim() === countryName);
            
            // If no exact match, try case-insensitive match
            if (!countryOption) {
                countryOption = Array.from(countrySelect.options).find(opt => 
                    opt.textContent.trim().toLowerCase() === countryName.toLowerCase()
                );
            }
            
            // If still no match, try partial match (country name contains or is contained by option)
            if (!countryOption) {
                countryOption = Array.from(countrySelect.options).find(opt => {
                    const optText = opt.textContent.trim().toLowerCase();
                    const countryLower = countryName.toLowerCase();
                    return optText.includes(countryLower) || countryLower.includes(optText);
                });
            }
            
            if (countryOption) {
                countrySelect.value = countryOption.value;
            } else {
                // If no match found, try to use the country name directly as value
                console.warn('Could not find exact match for country:', countryName);
                // Try to use the country name directly as value (if it matches an option value)
                const valueMatch = Array.from(countrySelect.options).find(opt => opt.value === countryName);
                if (valueMatch) {
                    countrySelect.value = countryName;
                } else {
                    // Last resort: set the first option that contains the country name
                    const partialMatch = Array.from(countrySelect.options).find(opt => 
                        opt.textContent.toLowerCase().includes(countryName.toLowerCase().substring(0, 3))
                    );
                    if (partialMatch) {
                        countrySelect.value = partialMatch.value;
                    }
                }
            }
            
            // Trigger search automatically if both city and country are detected
            setTimeout(() => {
                // Check both countrySelect.value and countryInput.value
                const hasCountry = countrySelect.value || countryInput.value.trim();
                if (cityInput.value && hasCountry) {
                    searchBtn.click();
                }
            }, 500);
        })();
        {% endif %}
        
        // Comprehensive country list (ISO 3166-1)
        const countries = [
            "Afghanistan", "Albania", "Algeria", "Andorra", "Angola", "Argentina", "Armenia", 
            "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", 
            "Belarus", "Belgium", "Belize", "Benin", "Bhutan", "Bolivia", "Bosnia and Herzegovina", 
            "Botswana", "Brazil", "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", 
            "Cameroon", "Canada", "Cape Verde", "Central African Republic", "Chad", "Chile", 
            "China", "Colombia", "Comoros", "Congo", "Costa Rica", "Croatia", "Cuba", "Cyprus", 
            "Czech Republic", "Denmark", "Djibouti", "Dominican Republic", "Ecuador", "Egypt", 
            "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Eswatini", "Ethiopia", 
            "Fiji", "Finland", "France", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", 
            "Greece", "Grenada", "Guatemala", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", 
            "Honduras", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", 
            "Israel", "Italy", "Ivory Coast", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", 
            "Kiribati", "Kuwait", "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia", 
            "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Madagascar", "Malawi", "Malaysia", 
            "Maldives", "Mali", "Malta", "Mauritania", "Mauritius", "Mexico", "Moldova", "Monaco", 
            "Mongolia", "Montenegro", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", 
            "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Niger", "Nigeria", "North Korea", 
            "North Macedonia", "Norway", "Oman", "Pakistan", "Palau", "Palestine", "Panama", 
            "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Qatar", 
            "Romania", "Russia", "Rwanda", "Saint Lucia", "Samoa", "San Marino", "Saudi Arabia", 
            "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", 
            "Solomon Islands", "Somalia", "South Africa", "South Korea", "South Sudan", "Spain", 
            "Sri Lanka", "Sudan", "Suriname", "Sweden", "Switzerland", "Syria", "Taiwan", 
            "Tajikistan", "Tanzania", "Thailand", "Timor-Leste", "Togo", "Tonga", "Trinidad and Tobago", 
            "Tunisia", "Turkey", "Turkmenistan", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", 
            "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican City", 
            "Venezuela", "Vietnam", "Yemen", "Zambia", "Zimbabwe"
        ];
        
        // Populate country dropdown (hidden select for form submission)
        countries.forEach(country => {
            const option = document.createElement('option');
            option.value = country;
            option.textContent = country;
            countrySelect.appendChild(option);
        });
        
        // Country search functionality
        let countrySearchTimeout = null;
        countryInput.addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();
            
            if (countrySearchTimeout) {
                clearTimeout(countrySearchTimeout);
            }
            
            // Reset selection when input changes
            selectedCountryIndex = -1;
            
            if (query.length === 0) {
                countryDropdown.classList.remove('show');
                countrySelect.value = '';
                selectedCountryIndex = -1;
                return;
            }
            
            countrySearchTimeout = setTimeout(() => {
                const filtered = countries.filter(c => 
                    c.toLowerCase().includes(query)
                ).slice(0, 10); // Limit to 10 results
                
                countryDropdown.innerHTML = '';
                if (filtered.length === 0) {
                    countryDropdown.classList.remove('show');
                    return;
                }
                
                filtered.forEach((country, index) => {
                    const div = document.createElement('div');
                    div.className = 'country-option';
                    div.textContent = country;
                    
                    // Function to select this country (used by both click and keyboard)
                    const selectCountry = () => {
                        countryInput.value = country;
                        countrySelect.value = country;
                        countryDropdown.classList.remove('show');
                        selectedCountryIndex = -1; // Reset selection
                    };
                    
                    div.addEventListener('click', selectCountry);
                    countryDropdown.appendChild(div);
                });
                
                countryDropdown.classList.add('show');
                selectedCountryIndex = -1; // Reset selection when new suggestions are shown
            }, 200);
        });
        
        // Keyboard navigation for country suggestions
        countryInput.addEventListener('keydown', (e) => {
            const countryOptions = countryDropdown.querySelectorAll('.country-option');
            
            if (!countryDropdown.classList.contains('show') || countryOptions.length === 0) {
                // If suggestions are not visible, allow Enter key to work normally
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedCountryIndex = (selectedCountryIndex + 1) % countryOptions.length;
                    updateCountrySelection(countryOptions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedCountryIndex = selectedCountryIndex <= 0 
                        ? countryOptions.length - 1 
                        : selectedCountryIndex - 1;
                    updateCountrySelection(countryOptions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedCountryIndex >= 0 && selectedCountryIndex < countryOptions.length) {
                        countryOptions[selectedCountryIndex].click();
                    } else {
                        // If no selection, close dropdown
                        countryDropdown.classList.remove('show');
                        selectedCountryIndex = -1;
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    countryDropdown.classList.remove('show');
                    selectedCountryIndex = -1;
                    break;
            }
        });
        
        function updateCountrySelection(countryOptions) {
            countryOptions.forEach((item, index) => {
                if (index === selectedCountryIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        // Hide country dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!countryInput.contains(e.target) && !countryDropdown.contains(e.target)) {
                countryDropdown.classList.remove('show');
                selectedCountryIndex = -1;
            }
        });
        
        // Allow selecting from hidden select (for keyboard users)
        countrySelect.addEventListener('change', (e) => {
            if (e.target.value) {
                countryInput.value = e.target.value;
            }
        });
        
        // City autocomplete using OpenStreetMap Nominatim (free API)
        cityInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            
            // Clear previous timeout
            if (autocompleteTimeout) {
                clearTimeout(autocompleteTimeout);
            }
            
            if (query.length < 2) {
                citySuggestions.classList.remove('show');
                return;
            }
            
            // Debounce API calls (500ms delay)
            autocompleteTimeout = setTimeout(() => fetchCitySuggestions(query), 500);
        });
        
        async function fetchCitySuggestions(query) {
            try {
                const countryCode = getCountryCode(countrySelect.value);
                // Request address details for better structured data
                let url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&featuretype=city&addressdetails=1`;
                
                if (countryCode) {
                    url += `&countrycodes=${countryCode}`;
                }
                
                const response = await fetch(url, {
                    headers: { 
                        'Accept-Language': '{{ lang }}',
                        'User-Agent': 'CineStream/1.0' // Required by Nominatim
                    }
                });
                
                const results = await response.json();
                displayCitySuggestions(results);
            } catch (e) {
                console.error('Autocomplete error:', e);
                citySuggestions.classList.remove('show');
            }
        }
        
        function displayCitySuggestions(results) {
            if (results.length === 0) {
                citySuggestions.classList.remove('show');
                selectedSuggestionIndex = -1;
                return;
            }
            
            citySuggestions.innerHTML = '';
            selectedSuggestionIndex = -1; // Reset selection when new suggestions are shown
            results.forEach((result, index) => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                
                // Extract city, state, and country from Nominatim API response
                // Prefer structured address object over parsing display_name
                let cityName = '';
                let stateName = '';
                let countryName = '';
                
                if (result.address) {
                    // Use structured address data (more reliable)
                    cityName = result.address.city || 
                              result.address.town || 
                              result.address.village || 
                              result.address.municipality ||
                              result.address.county ||
                              '';
                    
                    // State/province can be in different fields
                    stateName = result.address.state || 
                               result.address.province || 
                               result.address.region ||
                               result.address.state_district ||
                               '';
                    
                    countryName = result.address.country || '';
                }
                
                // Fallback to parsing display_name if address object is incomplete
                if (!cityName || !countryName) {
                    const parts = result.display_name.split(', ');
                    if (!cityName) {
                        cityName = parts[0];
                    }
                    if (!countryName) {
                        countryName = parts[parts.length - 1];
                    }
                    if (!stateName && parts.length >= 3) {
                        stateName = parts.slice(1, -1).join(', ');
                    }
                }
                
                // Clean up extracted values
                cityName = cityName.trim();
                stateName = stateName.trim();
                countryName = countryName.trim();
                
                // Build display text
                let displayText = cityName;
                if (stateName) {
                    displayText += ` <small>(${stateName}, ${countryName})</small>`;
                } else {
                    displayText += ` <small>(${countryName})</small>`;
                }
                
                div.innerHTML = displayText;
                
                // Store full location data in data attributes
                div.dataset.city = cityName;
                div.dataset.state = stateName;
                div.dataset.country = countryName;
                
                // Function to select this suggestion (used by both click and keyboard)
                const selectSuggestion = () => {
                    // Set city name
                    cityInput.value = cityName;
                    
                    // Try to match and select the country
                    // First, normalize country name (remove common suffixes, handle abbreviations)
                    const normalizeCountryName = (name) => {
                        return name.toLowerCase()
                            .replace(/\s+/g, ' ')
                            .trim();
                    };
                    
                    const countryLower = normalizeCountryName(countryName);
                    
                    // Common country name mappings (API might return different names)
                    const countryMappings = {
                        'usa': 'United States',
                        'us': 'United States',
                        'united states of america': 'United States',
                        'united states': 'United States',
                        'uk': 'United Kingdom',
                        'united kingdom': 'United Kingdom',
                        'united kingdom of great britain and northern ireland': 'United Kingdom',
                        'russian federation': 'Russia',
                        'russia': 'Russia',
                        'czechia': 'Czech Republic',
                        'czech republic': 'Czech Republic',
                        'myanmar': 'Myanmar',
                        'burma': 'Myanmar',
                        'east timor': 'Timor-Leste',
                        'timor-leste': 'Timor-Leste',
                        'swaziland': 'Eswatini',
                        'eswatini': 'Eswatini',
                        'macedonia': 'North Macedonia',
                        'north macedonia': 'North Macedonia',
                        'c√¥te d\'ivoire': 'Ivory Coast',
                        'cote d\'ivoire': 'Ivory Coast',
                        'ivory coast': 'Ivory Coast',
                        'south korea': 'South Korea',
                        'republic of korea': 'South Korea',
                        'north korea': 'North Korea',
                        'democratic people\'s republic of korea': 'North Korea',
                        'dprk': 'North Korea'
                    };
                    
                    // Check mappings first
                    let matchedCountry = null;
                    if (countryMappings[countryLower]) {
                        matchedCountry = countryMappings[countryLower];
                    } else {
                        // Try exact match
                        matchedCountry = countries.find(c => {
                            const cLower = normalizeCountryName(c);
                            return cLower === countryLower;
                        });
                        
                        // Try contains match (either direction)
                        if (!matchedCountry) {
                            matchedCountry = countries.find(c => {
                                const cLower = normalizeCountryName(c);
                                return countryLower.includes(cLower) || cLower.includes(countryLower);
                            });
                        }
                        
                        // Try word-based matching for multi-word countries
                        if (!matchedCountry) {
                            const countryWords = countryLower.split(/\s+/).filter(w => w.length > 2);
                            matchedCountry = countries.find(c => {
                                const cLower = normalizeCountryName(c);
                                const cWords = cLower.split(/\s+/);
                                // Check if significant words match
                                return countryWords.some(word => cWords.includes(word)) ||
                                       cWords.some(word => countryWords.includes(word));
                            });
                        }
                    }
                    
                    // Always set the country - try to match first, then use the country name from API
                    if (matchedCountry) {
                        // Update both the hidden select and visible input with matched country
                        countrySelect.value = matchedCountry;
                        countryInput.value = matchedCountry;
                        console.log(`‚úì Country matched: "${countryName}" -> "${matchedCountry}"`);
                    } else {
                        // If no match found, try to find the closest match or set as-is
                        // First, try to find by first word (e.g., "United" for "United States")
                        const firstWord = countryLower.split(/\s+/)[0];
                        const partialMatch = countries.find(c => {
                            const cLower = normalizeCountryName(c);
                            return cLower.startsWith(firstWord) || firstWord.length > 3 && cLower.includes(firstWord);
                        });
                        
                        if (partialMatch) {
                            countrySelect.value = partialMatch;
                            countryInput.value = partialMatch;
                            console.log(`‚úì Country partially matched: "${countryName}" -> "${partialMatch}"`);
                        } else {
                            // Set the country name as-is in the input (user can verify/correct)
                            countryInput.value = countryName;
                            // Try to find similar countries for user reference
                            const similar = countries.filter(c => {
                                const cLower = normalizeCountryName(c);
                                return cLower.includes(countryLower.substring(0, 3)) || 
                                       countryLower.includes(cLower.substring(0, 3));
                            }).slice(0, 3);
                            
                            console.warn(`‚ö† Could not match country "${countryName}" to country list`);
                            if (similar.length > 0) {
                                console.log(`   Similar countries found: ${similar.join(', ')}`);
                                // Auto-select the first similar country if very close match
                                if (similar.length === 1 || countryLower.length <= 5) {
                                    countrySelect.value = similar[0];
                                    countryInput.value = similar[0];
                                    console.log(`   Auto-selected closest match: "${similar[0]}"`);
                                }
                            }
                        }
                    }
                    
                    // Ensure country is always set (fallback to countryName if nothing else worked)
                    if (!countryInput.value || countryInput.value.trim() === '') {
                        countryInput.value = countryName;
                        console.log(`   Set country to API value: "${countryName}"`);
                    }
                    
                    // Store state for later use (always check if stateName is not empty)
                    if (stateName && stateName.length > 0) {
                        cityInput.dataset.state = stateName;
                        console.log(`‚úì State stored: "${stateName}"`);
                    } else {
                        delete cityInput.dataset.state;
                    }
                    
                    // Log summary for debugging
                    console.log(`Selected location: City="${cityName}", State="${stateName || '(none)'}", Country="${matchedCountry || countryName}"`);
                    
                    // Close suggestions
                    citySuggestions.classList.remove('show');
                    selectedSuggestionIndex = -1;
                };
                
                div.addEventListener('click', selectSuggestion);
                
                citySuggestions.appendChild(div);
            });
            
            citySuggestions.classList.add('show');
        }
        
        // Complete ISO 3166-1 alpha-2 country codes for Nominatim (matches all countries in list)
        function getCountryCode(countryName) {
            const codes = {
                "Afghanistan": "af", "Albania": "al", "Algeria": "dz", "Andorra": "ad", 
                "Angola": "ao", "Argentina": "ar", "Armenia": "am", "Australia": "au", 
                "Austria": "at", "Azerbaijan": "az", "Bahamas": "bs", "Bahrain": "bh", 
                "Bangladesh": "bd", "Barbados": "bb", "Belarus": "by", "Belgium": "be", 
                "Belize": "bz", "Benin": "bj", "Bhutan": "bt", "Bolivia": "bo", 
                "Bosnia and Herzegovina": "ba", "Botswana": "bw", "Brazil": "br", 
                "Brunei": "bn", "Bulgaria": "bg", "Burkina Faso": "bf", "Burundi": "bi", 
                "Cambodia": "kh", "Cameroon": "cm", "Canada": "ca", "Cape Verde": "cv", 
                "Central African Republic": "cf", "Chad": "td", "Chile": "cl", "China": "cn", 
                "Colombia": "co", "Comoros": "km", "Congo": "cg", "Costa Rica": "cr", 
                "Croatia": "hr", "Cuba": "cu", "Cyprus": "cy", "Czech Republic": "cz", 
                "Denmark": "dk", "Djibouti": "dj", "Dominican Republic": "do", "Ecuador": "ec", 
                "Egypt": "eg", "El Salvador": "sv", "Equatorial Guinea": "gq", "Eritrea": "er", 
                "Estonia": "ee", "Eswatini": "sz", "Ethiopia": "et", "Fiji": "fj", 
                "Finland": "fi", "France": "fr", "Gabon": "ga", "Gambia": "gm", 
                "Georgia": "ge", "Germany": "de", "Ghana": "gh", "Greece": "gr", 
                "Grenada": "gd", "Guatemala": "gt", "Guinea": "gn", "Guinea-Bissau": "gw", 
                "Guyana": "gy", "Haiti": "ht", "Honduras": "hn", "Hungary": "hu", 
                "Iceland": "is", "India": "in", "Indonesia": "id", "Iran": "ir", 
                "Iraq": "iq", "Ireland": "ie", "Israel": "il", "Italy": "it", 
                "Ivory Coast": "ci", "Jamaica": "jm", "Japan": "jp", "Jordan": "jo", 
                "Kazakhstan": "kz", "Kenya": "ke", "Kiribati": "ki", "Kuwait": "kw", 
                "Kyrgyzstan": "kg", "Laos": "la", "Latvia": "lv", "Lebanon": "lb", 
                "Lesotho": "ls", "Liberia": "lr", "Libya": "ly", "Liechtenstein": "li", 
                "Lithuania": "lt", "Luxembourg": "lu", "Madagascar": "mg", "Malawi": "mw", 
                "Malaysia": "my", "Maldives": "mv", "Mali": "ml", "Malta": "mt", 
                "Mauritania": "mr", "Mauritius": "mu", "Mexico": "mx", "Moldova": "md", 
                "Monaco": "mc", "Mongolia": "mn", "Montenegro": "me", "Morocco": "ma", 
                "Mozambique": "mz", "Myanmar": "mm", "Namibia": "na", "Nauru": "nr", 
                "Nepal": "np", "Netherlands": "nl", "New Zealand": "nz", "Nicaragua": "ni", 
                "Niger": "ne", "Nigeria": "ng", "North Korea": "kp", "North Macedonia": "mk", 
                "Norway": "no", "Oman": "om", "Pakistan": "pk", "Palau": "pw", 
                "Palestine": "ps", "Panama": "pa", "Papua New Guinea": "pg", "Paraguay": "py", 
                "Peru": "pe", "Philippines": "ph", "Poland": "pl", "Portugal": "pt", 
                "Qatar": "qa", "Romania": "ro", "Russia": "ru", "Rwanda": "rw", 
                "Saint Lucia": "lc", "Samoa": "ws", "San Marino": "sm", "Saudi Arabia": "sa", 
                "Senegal": "sn", "Serbia": "rs", "Seychelles": "sc", "Sierra Leone": "sl", 
                "Singapore": "sg", "Slovakia": "sk", "Slovenia": "si", "Solomon Islands": "sb", 
                "Somalia": "so", "South Africa": "za", "South Korea": "kr", "South Sudan": "ss", 
                "Spain": "es", "Sri Lanka": "lk", "Sudan": "sd", "Suriname": "sr", 
                "Sweden": "se", "Switzerland": "ch", "Syria": "sy", "Taiwan": "tw", 
                "Tajikistan": "tj", "Tanzania": "tz", "Thailand": "th", "Timor-Leste": "tl", 
                "Togo": "tg", "Tonga": "to", "Trinidad and Tobago": "tt", "Tunisia": "tn", 
                "Turkey": "tr", "Turkmenistan": "tm", "Tuvalu": "tv", "Uganda": "ug", 
                "Ukraine": "ua", "United Arab Emirates": "ae", "United Kingdom": "gb", 
                "United States": "us", "Uruguay": "uy", "Uzbekistan": "uz", "Vanuatu": "vu", 
                "Vatican City": "va", "Venezuela": "ve", "Vietnam": "vn", "Yemen": "ye", 
                "Zambia": "zm", "Zimbabwe": "zw"
            };
            return codes[countryName] || '';
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!cityInput.contains(e.target) && !citySuggestions.contains(e.target)) {
                citySuggestions.classList.remove('show');
            }
        });
        
        // Search button click handler
        searchBtn.addEventListener('click', async () => {
            const city = cityInput.value.trim();
            // Get country from select first, fallback to input if select is empty
            let country = countrySelect.value;
            if (!country && countryInput.value.trim()) {
                // If select is empty but input has value, try to match it
                const countryInputValue = countryInput.value.trim();
                const matchedOption = Array.from(countrySelect.options).find(opt => 
                    opt.textContent.trim() === countryInputValue || opt.value === countryInputValue
                );
                if (matchedOption) {
                    country = matchedOption.value;
                    countrySelect.value = country;
                } else {
                    // Use the input value directly if no match found
                    country = countryInputValue;
                }
            }
            const state = cityInput.dataset.state || '';  // Get state from autocomplete if available
            
            // Hide suggestions
            citySuggestions.classList.remove('show');
            
            // Clear any existing polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            if (!city) {
                showEmptyState('Please enter a city name', 'üèôÔ∏è');
                return;
            }
            
            if (!country) {
                showEmptyState('Please select a country', 'üåç');
                return;
            }
            
            currentCity = city;
            currentCountry = country;
            
            showLoadingSkeleton();
            
            // First, check if data is already available before triggering a scrape
            const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
            try {
                const params = new URLSearchParams({city_name: locationId});
                if (formatFilter.value) params.append('format', formatFilter.value);
                if (languageFilter.value) params.append('language', languageFilter.value);
                
                const existingDataResponse = await fetch(`/api/showtimes?${params}`);
                const existingShowtimes = await existingDataResponse.json();
                
                // If we have showtimes available, display them immediately (no need to scrape)
                if (existingShowtimes && Array.isArray(existingShowtimes) && existingShowtimes.length > 0) {
                    hideLoadingOverlay(); // Stop animation
                    showtimes = applyFilters(existingShowtimes);
                    renderShowtimes();
                    return; // Data is available, no need to trigger scrape
                }
            } catch (e) {
                // If checking existing data fails, continue to scrape
                console.log('Could not check existing data, proceeding with scrape...');
            }
            
            // Data not available or check failed - trigger scraping
            await fetchShowtimes(city, country, state);
        });
        
        // Keyboard navigation for city and country suggestions
        let selectedSuggestionIndex = -1;
        let selectedCountryIndex = -1;
        
        cityInput.addEventListener('keydown', (e) => {
            const suggestions = citySuggestions.querySelectorAll('.suggestion-item');
            
            if (!citySuggestions.classList.contains('show') || suggestions.length === 0) {
                // If suggestions are not visible, handle Enter key to search
                if (e.key === 'Enter') {
                    e.preventDefault();
                    citySuggestions.classList.remove('show');
                    searchBtn.click();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedSuggestionIndex = (selectedSuggestionIndex + 1) % suggestions.length;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedSuggestionIndex = selectedSuggestionIndex <= 0 
                        ? suggestions.length - 1 
                        : selectedSuggestionIndex - 1;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < suggestions.length) {
                        // Get the selected suggestion's data
                        const selectedItem = suggestions[selectedSuggestionIndex];
                        const cityName = selectedItem.dataset.city;
                        const stateName = selectedItem.dataset.state || '';
                        const countryName = selectedItem.dataset.country;
                        
                        // Set city name
                        cityInput.value = cityName;
                        
                        // Use the same country matching logic as click handler
                        const normalizeCountryName = (name) => {
                            return name.toLowerCase()
                                .replace(/\s+/g, ' ')
                                .trim();
                        };
                        
                        const countryLower = normalizeCountryName(countryName);
                        
                        // Common country name mappings
                        const countryMappings = {
                            'usa': 'United States',
                            'us': 'United States',
                            'united states of america': 'United States',
                            'uk': 'United Kingdom',
                            'united kingdom of great britain and northern ireland': 'United Kingdom',
                            'russian federation': 'Russia',
                            'czechia': 'Czech Republic',
                            'myanmar': 'Myanmar',
                            'burma': 'Myanmar',
                            'east timor': 'Timor-Leste',
                            'swaziland': 'Eswatini',
                            'macedonia': 'North Macedonia',
                            'north macedonia': 'North Macedonia',
                            'c√¥te d\'ivoire': 'Ivory Coast',
                            'ivory coast': 'Ivory Coast'
                        };
                        
                        let matchedCountry = null;
                        if (countryMappings[countryLower]) {
                            matchedCountry = countryMappings[countryLower];
                        } else {
                            matchedCountry = countries.find(c => {
                                const cLower = normalizeCountryName(c);
                                return cLower === countryLower;
                            });
                            
                            if (!matchedCountry) {
                                matchedCountry = countries.find(c => {
                                    const cLower = normalizeCountryName(c);
                                    return countryLower.includes(cLower) || cLower.includes(countryLower);
                                });
                            }
                            
                            if (!matchedCountry) {
                                const countryWords = countryLower.split(/\s+/).filter(w => w.length > 2);
                                matchedCountry = countries.find(c => {
                                    const cLower = normalizeCountryName(c);
                                    const cWords = cLower.split(/\s+/);
                                    return countryWords.some(word => cWords.includes(word)) ||
                                           cWords.some(word => countryWords.includes(word));
                                });
                            }
                        }
                        
                        if (matchedCountry) {
                            countrySelect.value = matchedCountry;
                            countryInput.value = matchedCountry;
                        } else {
                            countryInput.value = countryName;
                            console.warn(`Could not match country "${countryName}" to country list`);
                        }
                        
                        // Store state
                        if (stateName) {
                            cityInput.dataset.state = stateName;
                        } else {
                            delete cityInput.dataset.state;
                        }
                        
                        citySuggestions.classList.remove('show');
                        selectedSuggestionIndex = -1;
                    } else {
                        citySuggestions.classList.remove('show');
                        searchBtn.click();
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    citySuggestions.classList.remove('show');
                    selectedSuggestionIndex = -1;
                    break;
            }
        });
        
        function updateSuggestionSelection(suggestions) {
            suggestions.forEach((item, index) => {
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        
        // Clear state when city input changes manually
        cityInput.addEventListener('input', (e) => {
            if (!e.target.dataset.state) {
                // Only clear if user is typing (not from autocomplete selection)
                delete cityInput.dataset.state;
            }
        });
        
        async function fetchShowtimes(city, country, state = '') {
            try {
                const scrapeResponse = await fetch('/api/scrape', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        city: city, 
                        country: country,
                        state: state
                    })
                });
                
                const data = await scrapeResponse.json();
                
                if (scrapeResponse.status === 202) {
                    // Scraping in progress by another request - start polling
                    const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                    showLoadingState('Scraping showtimes');
                    startPolling(locationId);
                    return;
                }
                
                // If we get showtimes directly, render them immediately (stop animation)
                if (data.showtimes && Array.isArray(data.showtimes) && data.showtimes.length > 0) {
                    hideLoadingOverlay(); // Stop animation immediately
                    showtimes = applyFilters(data.showtimes);
                    renderShowtimes();
                    return;
                }
                
                // Check if response contains showtimes (even if empty array)
                if (data.showtimes && Array.isArray(data.showtimes)) {
                    // Use showtimes from response immediately! (stop animation)
                    hideLoadingOverlay(); // Stop animation
                    showtimes = applyFilters(data.showtimes);
                    renderShowtimes();
                    return;
                } else if (data.status === 'success' || data.status === 'fresh') {
                    // Fallback: fetch showtimes separately (shouldn't happen with new API)
                    const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                    hideLoadingOverlay(); // Stop animation before loading
                    await loadShowtimes(locationId);
                } else if (data.status === 'error') {
                    // Error occurred - stop animation and show error
                    hideLoadingOverlay();
                    showErrorState(data.message || 'An error occurred', () => fetchShowtimes(city, country, state));
                }
            } catch (e) {
                console.error('Scrape error:', e);
                // Stop animation on error
                hideLoadingOverlay();
                showErrorState('Error connecting to server. Please check your internet connection.', () => fetchShowtimes(city, country, state));
            }
        }
        
        function startPolling(locationId) {
            let pollCount = 0;
            // Poll every 2 seconds for status updates
            pollingInterval = setInterval(async () => {
                try {
                    pollCount++;
                    const statusResponse = await fetch(`/api/scrape/status/${encodeURIComponent(locationId)}`);
                    const statusData = await statusResponse.json();
                    
                    // FIRST: Check if showtimes are available (even during daily refresh)
                    // Always try to load data first - if it exists, show it immediately
                    let dataLoaded = false;
                    try {
                        const params = new URLSearchParams({city_name: locationId});
                        if (formatFilter.value) params.append('format', formatFilter.value);
                        if (languageFilter.value) params.append('language', languageFilter.value);
                        
                        const testResponse = await fetch(`/api/showtimes?${params}`);
                        const testShowtimes = await testResponse.json();
                        
                        // If we got showtimes (even if daily refresh is running), display them immediately
                        // BUT: Check status first - if status is 'error', show error instead of empty state
                        if (testShowtimes && Array.isArray(testShowtimes)) {
                            // Check status to see if there was an error BEFORE checking showtimes
                            if (statusData.status === 'error') {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                hideLoadingOverlay();
                                const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                showErrorState(errorMsg, () => {
                                    const city = cityInput.value.trim();
                                    const country = countrySelect.value;
                                    const state = cityInput.dataset.state || '';
                                    if (city && country) {
                                        fetchShowtimes(city, country, state);
                                    }
                                });
                                dataLoaded = true;
                                return;
                            }
                            
                            clearInterval(pollingInterval);
                            pollingInterval = null;
                            hideLoadingOverlay(); // Stop animation immediately
                            if (testShowtimes.length > 0) {
                                showtimes = applyFilters(testShowtimes);
                                renderShowtimes(); // Display available data
                            } else {
                                // Data is ready but no showtimes found (only if not error status)
                                showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                            }
                            dataLoaded = true;
                            return; // Exit, don't continue polling
                        }
                    } catch (e) {
                        // If loading fails, continue to check status
                        console.log('Checking status...');
                    }
                    
                    // If data was loaded, we already returned above
                    // Now check status for fresh/ready data
                    if (statusData.status === 'fresh' || statusData.ready) {
                        // Data is ready! Stop polling and load showtimes immediately
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay(); // Stop animation before loading
                        await loadShowtimes(locationId);
                        return; // Exit early, don't continue polling
                    }
                    
                    // Only show loading state if we're still waiting (no data available yet)
                    if (!dataLoaded) {
                        // Update UI with current status (dots will be animated)
                        const statusMessage = statusData.processing_by === 'on-demand' 
                            ? 'Scraping showtimes' 
                            : (statusData.processing_by === 'daily-refresh' 
                                ? 'Daily refresh in progress' 
                                : 'Processing');
                        showLoadingState(statusMessage);
                    }
                    
                    if (statusData.status === 'stale' || statusData.status === 'error') {
                        // Scraping failed, stop polling
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay();
                        
                        // Always show error state for 'error' status, never show "no showtimes"
                        if (statusData.status === 'error') {
                            const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                            showErrorState(errorMsg, () => {
                                const city = cityInput.value.trim();
                                const country = countrySelect.value;
                                const state = cityInput.dataset.state || '';
                                if (city && country) {
                                    fetchShowtimes(city, country, state);
                                }
                            });
                        } else {
                            // Only show "no showtimes" for 'stale' status (not error)
                            const errorMsg = statusData.message || '{{ translations.no_showtimes or "No showtimes found" }}';
                            showEmptyState(errorMsg, 'üé¨');
                        }
                    }
                    // Otherwise keep polling (status is 'processing')
                } catch (e) {
                    console.error('Polling error:', e);
                    // After too many errors, stop polling and show error
                    if (pollCount > 30) { // 30 polls = 60 seconds
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay();
                        showErrorState('Request timed out. Please try again.', () => {
                            const city = cityInput.value.trim();
                            const country = countrySelect.value;
                            const state = cityInput.dataset.state || '';
                            if (city && country) {
                                fetchShowtimes(city, country, state);
                            }
                        });
                    }
                    // Otherwise continue polling on error (network issues, etc.)
                }
            }, 2000); // Poll every 2 seconds
        }
        
        async function loadShowtimes(locationId) {
            const params = new URLSearchParams({city_name: locationId});
            if (formatFilter.value) params.append('format', formatFilter.value);
            if (languageFilter.value) params.append('language', languageFilter.value);
            
            try {
                const response = await fetch(`/api/showtimes?${params}`);
                showtimes = await response.json();
                // Stop animation and render results
                hideLoadingOverlay();
                renderShowtimes();
            } catch (e) {
                console.error('Error loading showtimes:', e);
                // Stop animation on error
                hideLoadingOverlay();
                showErrorState('Error loading showtimes. Please try again.', () => loadShowtimes(locationId));
            }
        }
        
        function applyFilters(data) {
            let filtered = [...data];
            
            // Filter out past showtimes first (before other filters)
            const now = new Date();
            filtered = filtered.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (formatFilter.value) {
                filtered = filtered.filter(s => s.format && s.format === formatFilter.value);
            }
            if (languageFilter.value) {
                filtered = filtered.filter(s => 
                    (s.language || '').toLowerCase().includes(languageFilter.value.toLowerCase())
                );
            }
            
            // Sort by start_time (ascending - earliest first)
            filtered.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            return filtered;
        }
        
        // Helper functions for UI states
        function showLoadingSkeleton() {
            // Clear any existing skeleton timeout
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Show spinner first, then skeleton after a brief moment
            showLoadingState('Preparing to load showtimes...');
            skeletonTimeout = setTimeout(() => {
                // Only show skeleton if we're still loading (no error/result shown yet)
                if (container.querySelector('.loading-skeleton') === null && 
                    container.querySelector('.error-state') === null &&
                    container.querySelector('.empty-state') === null) {
                    container.innerHTML = `
                        <div class="loading-skeleton">
                            ${Array(6).fill(0).map(() => `
                                <div class="skeleton-card">
                                    <div class="skeleton-image"></div>
                                    <div class="skeleton-content">
                                        <div class="skeleton-line short"></div>
                                        <div class="skeleton-line medium"></div>
                                        <div class="skeleton-line"></div>
                                        <div class="skeleton-line short"></div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                skeletonTimeout = null;
            }, 500);
        }
        
        function clearLoadingSkeleton() {
            // Clear skeleton timeout if it exists
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Remove skeleton from DOM if present
            const skeleton = container.querySelector('.loading-skeleton');
            if (skeleton) {
                skeleton.remove();
            }
        }
        
        function showLoadingState(message = 'Loading...') {
            // Create or update full-page loading overlay
            let overlay = document.getElementById('loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'loading-overlay';
                overlay.className = 'loading-overlay';
                document.body.appendChild(overlay);
            }
            
            overlay.innerHTML = `
                <div class="loading-overlay-content">
                    <div class="spinner-glow">
                        <span style="font-size: 24px; color: var(--accent); text-shadow: 0 0 10px rgba(52, 152, 219, 0.8);">üé¨</span>
                    </div>
                    <p class="loading-text">${message}<span class="loading-dots"></span></p>
                    <p>Please wait while we fetch the latest showtimes...</p>
                </div>
            `;
            
            // Show overlay with animation
            setTimeout(() => {
                overlay.classList.add('show');
            }, 10);
        }
        
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Remove overlay after animation
                setTimeout(() => {
                    if (overlay && !overlay.classList.contains('show')) {
                        overlay.remove();
                    }
                }, 300);
            }
        }
        
        function showEmptyState(message, icon = 'üé¨') {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing empty state
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">${icon}</div>
                    <h3>${message}</h3>
                    <p>Try searching for a different city or check back later</p>
                </div>
            `;
        }
        
        function showErrorState(message, retryCallback = null) {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing error state
            const errorHtml = `
                <div class="error-state">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <h3>Something went wrong</h3>
                    <p>${message}</p>
                    ${retryCallback ? '<button class="retry-btn" id="retry-btn">Retry</button>' : ''}
                </div>
            `;
            container.innerHTML = errorHtml;
            
            if (retryCallback) {
                const retryBtn = document.getElementById('retry-btn');
                if (retryBtn) {
                    retryBtn.addEventListener('click', retryCallback);
                }
            }
        }
        
        function renderShowtimes() {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when rendering showtimes
            if (!showtimes || showtimes.length === 0) {
                showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                return;
            }
            
            // Filter out past showtimes on frontend (additional safety check)
            const now = new Date();
            const futureShowtimes = showtimes.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (futureShowtimes.length === 0) {
                showEmptyState('{{ translations.no_showtimes or "No upcoming showtimes found" }}', 'üé¨');
                return;
            }
            
            // Sort showtimes by start_time (ascending - earliest first)
            // This ensures showtimes are displayed in chronological order
            futureShowtimes.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            container.innerHTML = '<div class="showtimes-grid"></div>';
            const grid = container.querySelector('.showtimes-grid');
            
            futureShowtimes.forEach(st => {
                const card = document.createElement('div');
                card.className = 'showtime-card';
                
                const movieTitle = st.movie?.en || st.movie?.local || st.movie?.ua || st.movie?.ru || 'Unknown Movie';
                
                // Simplified date formatting - preserve timezone from ISO string
                let startTime;
                try {
                    const date = new Date(st.start_time);
                    if (isNaN(date.getTime())) {
                        startTime = 'Invalid date';
                    } else {
                        // Extract timezone from ISO string if present
                        const tzMatch = st.start_time.match(/([+-]\d{2}):(\d{2})$/);
                        const tzOffset = tzMatch ? tzMatch[0] : null;
                        
                        // Format date in locale-aware way
                        const options = {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        };
                        
                        startTime = date.toLocaleString('{{ lang }}', options);
                        
                        // Add timezone if not UTC
                        if (tzOffset && tzOffset !== '+00:00' && tzOffset !== 'Z') {
                            startTime += ` (UTC${tzOffset})`;
                        }
                    }
                } catch (e) {
                    startTime = st.start_time || 'Invalid date';
                }
                const cinemaName = st.cinema_name || st.cinema_id || 'Unknown Cinema';
                const cinemaAddress = st.cinema_address || '';
                const hallInfo = st.hall ? ` | ${st.hall}` : '';
                
                // Movie image with error handling
                const imagePath = st.movie_image_path || '';
                const imageHtml = imagePath 
                    ? `<img src="${imagePath}" alt="${movieTitle}" class="movie-image" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">`
                    : '';
                const placeholderHtml = `<div class="movie-image-placeholder" style="${imagePath ? 'display:none;' : ''}">üé¨</div>`;
                
                // Cinema address display
                const cinemaAddressHtml = cinemaAddress
                    ? `<div class="cinema-address">üìç ${cinemaAddress}</div>`
                    : '';
                
                card.innerHTML = `
                    <div class="movie-image-container">
                        ${imageHtml}
                        ${placeholderHtml}
                    </div>
                    <div class="showtime-card-content">
                        <h3>${movieTitle}</h3>
                        <div class="time">${startTime}</div>
                        <div class="cinema">
                            <div class="cinema-name">${cinemaName}</div>
                            ${cinemaAddressHtml}
                        </div>
                        <div style="margin-top: auto; padding-top: 1rem;">
                            <div style="margin-bottom: 0.5rem; opacity: 0.8;">${[st.format, st.language, hallInfo].filter(x => x).join(' | ')}</div>
                            ${st.cinema_website ? `<a href="${st.cinema_website}" target="_blank" class="buy-btn" aria-label="Buy tickets for ${movieTitle}">{{ translations.buy_tickets }}</a>` : ''}
                        </div>
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }
        
        // Filter event listeners
        [formatFilter, languageFilter].forEach(filter => {
            filter.addEventListener('change', () => {
                if (currentCity) {
                    const locationId = currentCountry ? `${currentCity}, ${currentCountry}` : currentCity;
                    loadShowtimes(locationId);
                }
            });
        });
        
        // Cleanup polling on page unload
        window.addEventListener('beforeunload', () => {
            if (pollingInterval) clearInterval(pollingInterval);
        });
        
        // Feedback Modal
        const feedbackBtn = document.getElementById('feedback-btn');
        const feedbackModal = document.getElementById('feedback-modal');
        const feedbackClose = document.getElementById('feedback-close');
        const feedbackCancel = document.getElementById('feedback-cancel');
        const feedbackForm = document.getElementById('feedback-form');
        const feedbackMessageDisplay = document.getElementById('feedback-message-display');
        
        function openFeedbackModal() {
            feedbackModal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }
        
        function closeFeedbackModal() {
            feedbackModal.style.display = 'none';
            document.body.style.overflow = 'auto';
            feedbackForm.reset();
            feedbackMessageDisplay.style.display = 'none';
        }
        
        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackClose.addEventListener('click', closeFeedbackModal);
        feedbackCancel.addEventListener('click', closeFeedbackModal);
        
        // Close modal when clicking outside
        feedbackModal.addEventListener('click', (e) => {
            if (e.target === feedbackModal) {
                closeFeedbackModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && feedbackModal.style.display === 'block') {
                closeFeedbackModal();
            }
        });
        
        // Handle feedback form submission
        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const submitBtn = feedbackForm.querySelector('.btn-submit');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            
            const formData = {
                name: document.getElementById('feedback-name').value.trim(),
                email: document.getElementById('feedback-email').value.trim(),
                message: document.getElementById('feedback-message').value.trim()
            };
            
            try {
                const response = await fetch('/api/feedback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });
                
                const data = await response.json();
                
                feedbackMessageDisplay.style.display = 'block';
                
                if (data.success) {
                    feedbackMessageDisplay.className = 'success';
                    feedbackMessageDisplay.textContent = '{{ translations.feedback_sent }}';
                    feedbackForm.reset();
                    
                    // Close modal after 2 seconds
                    setTimeout(() => {
                        closeFeedbackModal();
                    }, 2000);
                } else {
                    feedbackMessageDisplay.className = 'error';
                    feedbackMessageDisplay.textContent = data.error || '{{ translations.feedback_error }}';
                }
            } catch (error) {
                console.error('Feedback error:', error);
                feedbackMessageDisplay.style.display = 'block';
                feedbackMessageDisplay.className = 'error';
                feedbackMessageDisplay.textContent = '{{ translations.feedback_error }}';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });
    </script>
</body>
</html>



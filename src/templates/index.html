<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1a1f3a">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ translations.title }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --midnight-blue: #1a1f3a;
            --charcoal: #2c3e50;
            --slate: #34495e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --text-light: #ecf0f1;
            --text-dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--midnight-blue) 0%, var(--charcoal) 100%);
            color: var(--text-light);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* Header */
        header {
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        .nav-links {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .donate-btn {
            background: var(--success);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .donate-btn:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }
        
        .lang-selector {
            display: flex;
            gap: 0.5rem;
        }
        
        .lang-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .lang-btn:hover, .lang-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        /* Main Content */
        main {
            padding: 2rem 0;
        }
        
        .hero {
            text-align: center;
            padding: 3rem 0;
        }
        
        .hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent), #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .filters {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 2rem 0;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .location-search-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 1rem;
        }
        
        .additional-filters-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .filter-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--accent);
            display: flex;
            align-items: flex-start; /* Align to top to prevent misalignment */
            gap: 0.5rem;
            flex-wrap: wrap;
            min-height: 2.5rem; /* Reserve space for 2 lines of text to keep inputs aligned */
            line-height: 1.25;
        }
        
        /* Ensure all filter groups in the location search row have consistent alignment */
        .location-search-row .filter-group {
            justify-content: flex-start;
        }
        
        /* Keep inputs aligned at the same vertical position */
        .location-search-row .filter-group input,
        .location-search-row .filter-group select,
        .location-search-row .filter-group .country-input-group {
            margin-top: 0; /* Remove any top margin to keep alignment consistent */
        }
        
        .auto-detected-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid var(--accent);
            border-radius: 12px;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            user-select: none;
        }
        
        .auto-detected-badge:hover {
            background: rgba(52, 152, 219, 0.3);
            transform: scale(1.05);
        }
        
        .filter-group select,
        .filter-group input {
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .showtimes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .showtime-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0;
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }
        
        .movie-image-container {
            width: 100%;
            height: 300px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .movie-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        
        .showtime-card:hover .movie-image {
            transform: scale(1.05);
        }
        
        .movie-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--charcoal), var(--slate));
            color: var(--text-light);
            font-size: 3rem;
            opacity: 0.5;
        }
        
        .showtime-card-content {
            padding: 1.5rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card h3 {
            color: var(--accent);
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
        }
        
        .showtime-card .time {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0.5rem 0;
            color: var(--text-light);
        }
        
        .showtime-card .cinema {
            color: var(--text-light);
            margin-bottom: 0.5rem;
        }
        
        .showtime-card .cinema-name {
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }
        
        .showtime-card .cinema-address {
            font-size: 0.9rem;
            opacity: 0.9;
            color: var(--text-light);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .buy-btn {
            display: inline-block;
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }
        
        .buy-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.02);
        }
        
        .city-input-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .city-input-group input {
            flex: 1;
        }
        
        .search-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .search-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        .location-input-group {
            position: relative;
        }
        
        .location-input-group input {
            width: 100%;
            padding-right: 3rem; /* Make room for location button */
        }
        
        #manual-location-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s ease;
            color: var(--accent);
            line-height: 1;
        }
        
        #manual-location-btn:hover {
            background: rgba(52, 152, 219, 0.4);
            transform: translateY(-50%) scale(1.1);
        }
        
        #manual-location-btn:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .suggestions-dropdown.show {
            display: block;
        }
        
        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .suggestion-item:hover,
        .suggestion-item.selected {
            background: var(--accent);
        }
        
        .suggestion-item.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item small {
            opacity: 0.7;
        }
        
        /* Footer */
        footer {
            background: rgba(26, 31, 58, 0.95);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
        }
        
        .visitor-counter {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 1.5rem;
        }
        
        /* Full-page loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.show {
            opacity: 1;
        }
        
        .loading-overlay-content {
            text-align: center;
            color: white;
        }
        
        .loading-overlay .spinner-glow {
            margin: 0 auto 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Center the movie icon inside spinner */
        .loading-overlay .spinner-glow > * {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
            margin: 0;
        }
        
        .loading-overlay .loading-text {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .loading-overlay p {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 0.5rem;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }
        
        /* Loading Skeleton */
        .loading-skeleton {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .skeleton-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            animation: skeleton-pulse 1.5s ease-in-out infinite;
        }
        
        .skeleton-image {
            width: 100%;
            height: 300px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .skeleton-content {
            padding: 1.5rem;
        }
        
        .skeleton-line {
            height: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 0.75rem;
        }
        
        .skeleton-line.short {
            width: 60%;
        }
        
        .skeleton-line.medium {
            width: 80%;
        }
        
        @keyframes skeleton-pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        
        /* Spinner - Enhanced Cool Animation */
        .spinner {
            display: inline-block;
            width: 60px;
            height: 60px;
            position: relative;
            margin: 0 auto 1.5rem;
        }
        
        .spinner::before,
        .spinner::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
        }
        
        .spinner::before {
            width: 60px;
            height: 60px;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.3);
        }
        
        .spinner::after {
            width: 40px;
            height: 40px;
            top: 10px;
            left: 10px;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.3);
            animation: spin 0.8s linear infinite reverse;
        }
        
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        /* Enhanced Cool Spinner with Glow Effect */
        .spinner-glow {
            display: inline-block;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(52, 152, 219, 0.4) 0%, rgba(155, 89, 182, 0.2) 50%, transparent 70%);
            animation: pulse 2s ease-in-out infinite;
            margin: 0 auto 2rem;
            position: relative;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
        }
        
        .spinner-glow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            border: 5px solid transparent;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.4);
            border-bottom-color: rgba(52, 152, 219, 0.2);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6);
            margin: 0;
            z-index: 1;
            transform-origin: center center;
        }
        
        .spinner-glow::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 45px;
            height: 45px;
            border: 4px solid transparent;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.5);
            border-bottom-color: rgba(155, 89, 182, 0.2);
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);
            margin: 0;
            z-index: 2;
            transform-origin: center center;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
                box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.15);
                box-shadow: 0 0 40px rgba(52, 152, 219, 0.7), 0 0 80px rgba(155, 89, 182, 0.5);
            }
        }
        
        /* Movie icon animation in spinner center */
        @keyframes iconFloat {
            0%, 100% {
                transform: translate(-50%, -50%) translateY(0) rotate(0deg);
            }
            50% {
                transform: translate(-50%, -50%) translateY(-5px) rotate(5deg);
            }
        }
        
        .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
            z-index: 10;
        }
        
        /* Ensure iconFloat animation preserves centering for loading overlay */
        .loading-overlay .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
        }
        
        /* Loading text animation */
        .loading-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent);
            margin-top: 1.5rem;
            animation: fadeInOut 2s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            letter-spacing: 0.5px;
        }
        
        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0.7;
                transform: translateY(0);
            }
            50% {
                opacity: 1;
                transform: translateY(-3px);
            }
        }
        
        .loading-dots {
            display: inline-block;
            width: 1ch;
        }
        
        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% {
                content: '.';
            }
            40% {
                content: '..';
            }
            60%, 100% {
                content: '...';
            }
        }
        
        
        /* Error State */
        .error-state {
            text-align: center;
            padding: 3rem;
        }
        
        .error-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: var(--warning);
        }
        
        .error-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--warning);
        }
        
        .error-state p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .retry-btn {
            padding: 0.75rem 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .retry-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        /* Country Search Input */
        .country-input-group {
            position: relative;
        }
        
        .country-input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .country-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .country-dropdown.show {
            display: block;
        }
        
        .country-option {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .country-option:hover,
        .country-option.selected {
            background: var(--accent);
        }
        
        .country-option.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .country-option:last-child {
            border-bottom: none;
        }
        
        /* Focus States for Accessibility */
        *:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .filter-group input:focus,
        .filter-group select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .buy-btn:focus-visible,
        .search-btn:focus-visible,
        .donate-btn:focus-visible,
        .lang-btn:focus-visible,
        .retry-btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        /* Image Error Handling */
        .movie-image {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .movie-image[src=""],
        .movie-image:not([src]) {
            display: none;
        }
        
        /* Desktop Optimizations (Large Screens) */
        @media (min-width: 1200px) {
            .container {
                max-width: 1400px;
                padding: 0 40px;
            }
            
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: 2rem;
            }
            
            .filters {
                padding: 2rem;
            }
            
            .location-search-row {
                grid-template-columns: 2fr 1fr 1fr 1fr;
            }
            
            .hero h1 {
                font-size: 3.5rem;
            }
            
            .showtime-card-content {
                padding: 2rem;
            }
        }
        
        /* Desktop (Standard) */
        @media (min-width: 1024px) and (max-width: 1199px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
            
            .location-search-row {
                grid-template-columns: 2fr 1fr 1fr 1fr;
            }
        }
        
        /* Tablet and Medium Screens */
        @media (min-width: 769px) and (max-width: 1023px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
            
            .location-search-row {
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
            
            .location-search-row .city-group {
                grid-column: span 2;
            }
            
            .location-search-row .search-group {
                grid-column: span 2;
            }
        }
        
        /* Mobile and Small Tablets */
        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }
            
            header {
                padding: 0.75rem 0;
            }
            
            .logo {
                font-size: 1.25rem;
            }
            
            nav {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            
            .nav-links {
                gap: 0.5rem;
            }
            
            .lang-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }
            
            .donate-btn {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }
            
            main {
                padding: 1.5rem 0;
            }
            
            .hero {
                padding: 2rem 0;
            }
            
            .hero h1 {
                font-size: 2rem;
                margin-bottom: 0.75rem;
            }
            
            .hero p {
                font-size: 1rem;
            }
            
            .location-search-row {
                grid-template-columns: 1fr;
            }
            
            .additional-filters-row {
                grid-template-columns: 1fr;
            }
            
            .filters {
                padding: 1.25rem;
                gap: 1.25rem;
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 1 !important;
            }
            
            .filter-group label {
                font-size: 0.95rem;
                margin-bottom: 0.4rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.875rem;
                font-size: 1rem;
                min-height: 44px; /* Touch-friendly minimum */
            }
            
            .search-btn {
                padding: 0.875rem 1.5rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .showtimes-grid {
                grid-template-columns: 1fr;
                gap: 1.25rem;
                margin-top: 1.5rem;
            }
            
            .showtime-card {
                border-radius: 12px;
            }
            
            .showtime-card:hover {
                transform: none; /* Disable hover transform on mobile */
            }
            
            .movie-image-container {
                height: 250px;
            }
            
            .showtime-card-content {
                padding: 1.25rem;
            }
            
            .showtime-card h3 {
                font-size: 1.15rem;
            }
            
            .showtime-card .time {
                font-size: 1.1rem;
            }
            
            .buy-btn {
                padding: 0.875rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .loading-skeleton {
                grid-template-columns: 1fr;
                gap: 1.25rem;
            }
            
            .skeleton-image {
                height: 250px;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1.5rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 3rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.25rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 1rem;
            }
            
            .retry-btn {
                padding: 0.875rem 1.75rem;
                min-height: 44px;
                font-size: 1rem;
            }
            
            footer {
                padding: 1.5rem 0;
            }
            
            .visitor-counter {
                font-size: 1.1rem;
            }
        }
        
        /* Small Mobile Devices */
        @media (max-width: 480px) {
            .container {
                padding: 0 12px;
            }
            
            header {
                padding: 0.6rem 0;
            }
            
            .logo {
                font-size: 1.1rem;
            }
            
            .lang-selector {
                gap: 0.4rem;
            }
            
            .lang-btn {
                padding: 0.35rem 0.7rem;
                font-size: 0.85rem;
            }
            
            .donate-btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
            
            main {
                padding: 1rem 0;
            }
            
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
                margin-bottom: 0.5rem;
            }
            
            .hero p {
                font-size: 0.95rem;
            }
            
            .filters {
                padding: 1rem;
                gap: 1rem;
                border-radius: 8px;
            }
            
            .filter-group label {
                font-size: 0.9rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .search-btn {
                padding: 0.75rem 1.25rem;
                font-size: 0.95rem;
            }
            
            .showtimes-grid {
                gap: 1rem;
                margin-top: 1.25rem;
            }
            
            .movie-image-container {
                height: 220px;
            }
            
            .showtime-card-content {
                padding: 1rem;
            }
            
            .showtime-card h3 {
                font-size: 1.1rem;
            }
            
            .showtime-card .time {
                font-size: 1rem;
            }
            
            .showtime-card .cinema-address {
                font-size: 0.85rem;
            }
            
            .buy-btn {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .loading-skeleton {
                gap: 1rem;
            }
            
            .skeleton-image {
                height: 220px;
            }
            
            .skeleton-content {
                padding: 1rem;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 2.5rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.1rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 0.95rem;
            }
            
            .spinner {
                width: 35px;
                height: 35px;
            }
            
            footer {
                padding: 1.25rem 0;
            }
            
            .visitor-counter {
                font-size: 1rem;
            }
        }
        
        /* Very Small Mobile Devices */
        @media (max-width: 360px) {
            .hero h1 {
                font-size: 1.5rem;
            }
            
            .filters {
                padding: 0.875rem;
            }
            
            .movie-image-container {
                height: 200px;
            }
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--charcoal);
            margin: 5% auto;
            padding: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-header h2 {
            margin: 0;
            color: var(--accent);
            font-size: 1.5rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--warning);
        }
        
        .modal form {
            padding: 1.5rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent);
            font-weight: 600;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-color: var(--accent);
        }
        
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        
        .btn-cancel,
        .btn-submit {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-submit {
            background: var(--accent);
            color: white;
        }
        
        .btn-submit:hover {
            background: var(--accent-hover);
        }
        
        .btn-submit:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #feedback-message-display {
            padding: 1rem;
            border-radius: 5px;
            text-align: center;
        }
        
        #feedback-message-display.success {
            background: rgba(39, 174, 96, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        #feedback-message-display.error {
            background: rgba(243, 156, 18, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
            
            .modal-header {
                padding: 1rem;
            }
            
            .modal form {
                padding: 1rem;
            }
            
            .form-actions {
                flex-direction: column;
            }
            
            .btn-cancel,
            .btn-submit {
                width: 100%;
            }
        }
        
        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Disable hover effects on touch devices */
            .showtime-card:hover {
                transform: none;
                box-shadow: none;
            }
            
            .showtime-card:hover .movie-image {
                transform: none;
            }
            
            /* Increase touch targets */
            .lang-btn,
            .donate-btn,
            .search-btn,
            .buy-btn,
            .retry-btn {
                min-height: 44px;
            }
            
            .suggestion-item,
            .country-option {
                min-height: 44px;
                padding: 1rem 0.75rem;
            }
        }
        
        /* Desktop Hover Enhancements */
        @media (hover: hover) and (pointer: fine) {
            .showtime-card {
                cursor: pointer;
            }
            
            .suggestion-item:hover,
            .country-option:hover {
                background: var(--accent);
                transform: translateX(4px);
            }
        }
        
        /* Landscape Mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
            }
            
            .filters {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 2 !important;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav class="container">
            <a href="{{ base_path }}" style="text-decoration: none; color: inherit;"><div class="logo">CineStream</div></a>
            <div class="nav-links">
                <div class="lang-selector">
                    <a href="/set-language/en" class="lang-btn {{ 'active' if lang == 'en' else '' }}">EN</a>
                    <a href="/set-language/ua" class="lang-btn {{ 'active' if lang == 'ua' else '' }}">UA</a>
                    <a href="/set-language/ru" class="lang-btn {{ 'active' if lang == 'ru' else '' }}">RU</a>
                </div>
                <a href="{{ donation_url }}" target="_blank" class="donate-btn">üá∫üá¶ {{ translations.donate }}</a>
            </div>
        </nav>
    </header>
    
    <main class="container">
        <div class="hero">
            <h1>{{ translations.title }}</h1>
            <p>{{ translations.select_city }}</p>
        </div>
        
        <div class="filters">
            <div class="location-search-row">
                <div class="filter-group city-group">
                    <label for="city-input">
                        {{ translations.select_city }}
                        <span class="auto-detected-badge" id="auto-detected-badge" style="display: none;" title="Location auto-detected from your device. Click to clear.">üìç Auto-detected</span>
                    </label>
                    <div class="location-input-group">
                        <input type="text" id="city-input" placeholder="Enter city name..." autocomplete="off" aria-label="City name input">
                        <div id="city-suggestions" class="suggestions-dropdown" role="listbox" aria-label="City suggestions"></div>
                    </div>
                </div>
                
                <div class="filter-group state-group">
                    <label for="state-input">{{ translations.state_province or 'State/Province (optional)' }}</label>
                    <input type="text" id="state-input" placeholder="{{ translations.state_province or 'State/Province...' }}" autocomplete="off" aria-label="State or Province input">
                </div>
                
                <div class="filter-group country-group">
                    <label for="country-input">{{ translations.country or 'Country' }}</label>
                    <div class="country-input-group">
                        <input type="text" id="country-input" placeholder="Search or select country..." autocomplete="off" aria-label="Country selector">
                        <div id="country-dropdown" class="country-dropdown"></div>
                    </div>
                    <select id="country-select" style="display: none;" aria-label="Country selector">
                        <option value="">All Countries</option>
                    </select>
                </div>
                
                <div class="filter-group search-group">
                    <label>&nbsp;</label>
                    <button id="search-btn" class="search-btn" aria-label="Search for movie showtimes">üîç Search Showtimes</button>
                </div>
            </div>
            
            <div class="additional-filters-row">
                <div class="filter-group">
                    <label for="format-filter">{{ translations.filter_by_format }}</label>
                    <select id="format-filter" aria-label="Filter by movie format">
                        <option value="">All Formats</option>
                        <option value="2D">2D</option>
                        <option value="3D">3D</option>
                        <option value="IMAX">IMAX</option>
                        <option value="4DX">4DX</option>
                        <option value="Dolby Atmos">Dolby Atmos</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="language-filter">{{ translations.filter_by_language }}</label>
                    <select id="language-filter" aria-label="Filter by language">
                        <option value="">All Languages</option>
                        <option value="Ukrainian">Ukrainian</option>
                        <option value="English">English</option>
                        <option value="Russian">Russian</option>
                        <option value="Original">Original</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="showtimes-container">
            <div class="empty-state">
                <div class="empty-state-icon">üé¨</div>
                <h3>{{ translations.select_city or 'Select a City' }}</h3>
                <p>Enter a city name and country above to find movie showtimes</p>
            </div>
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p class="visitor-counter">{{ translations.visitor_count }}: {{ visitor_count }}</p>
            <div style="margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                <a href="/terms" style="color: var(--accent); text-decoration: none;">{{ translations.terms }}</a>
                <button id="feedback-btn" style="background: none; border: none; color: var(--accent); cursor: pointer; text-decoration: underline; font-size: inherit; font-family: inherit;">{{ translations.feedback }}</button>
            </div>
            <p style="margin-top: 1rem; opacity: 0.7;">¬© 2025 CineStream. All rights reserved.</p>
        </div>
    </footer>
    
    <!-- Feedback Modal -->
    <div id="feedback-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>{{ translations.feedback }}</h2>
                <button class="modal-close" id="feedback-close">&times;</button>
            </div>
            <form id="feedback-form">
                <div class="form-group">
                    <label for="feedback-name">Name (optional)</label>
                    <input type="text" id="feedback-name" name="name" placeholder="Your name">
                </div>
                <div class="form-group">
                    <label for="feedback-email">Email (optional)</label>
                    <input type="email" id="feedback-email" name="email" placeholder="your.email@example.com">
                </div>
                <div class="form-group">
                    <label for="feedback-message">Message <span style="color: var(--warning);">*</span></label>
                    <textarea id="feedback-message" name="message" rows="6" placeholder="Your feedback, suggestions, or questions..." required></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-cancel" id="feedback-cancel">Cancel</button>
                    <button type="submit" class="btn-submit">{{ translations.send_feedback }}</button>
                </div>
                <div id="feedback-message-display" style="margin-top: 1rem; display: none;"></div>
            </form>
        </div>
    </div>
    
    <script>
        // Feature detection for old devices
        var supportsFetch = typeof fetch !== 'undefined';
        var supportsAsyncAwait = (function() {
            try {
                new Function('async () => {}');
                return true;
            } catch (e) {
                return false;
            }
        })();
        var supportsArrayFrom = typeof Array.from !== 'undefined';
        var supportsArrayFind = Array.prototype.find !== undefined;
        var supportsArrayIncludes = Array.prototype.includes !== undefined;
        
        // Polyfill for Array.from (for IE11 and older)
        if (!supportsArrayFrom) {
            Array.from = function(arrayLike) {
                var result = [];
                for (var i = 0; i < arrayLike.length; i++) {
                    result.push(arrayLike[i]);
                }
                return result;
            };
        }
        
        // Polyfill for Array.find (for IE11 and older)
        if (!supportsArrayFind) {
            Array.prototype.find = function(predicate) {
                if (this == null) {
                    throw new TypeError('Array.prototype.find called on null or undefined');
                }
                if (typeof predicate !== 'function') {
                    throw new TypeError('predicate must be a function');
                }
                var list = Object(this);
                var length = parseInt(list.length) || 0;
                var thisArg = arguments[1];
                var value;
                for (var i = 0; i < length; i++) {
                    value = list[i];
                    if (predicate.call(thisArg, value, i, list)) {
                        return value;
                    }
                }
                return undefined;
            };
        }
        
        // Polyfill for Array.includes (for IE11 and older)
        if (!supportsArrayIncludes) {
            Array.prototype.includes = function(searchElement) {
                var O = Object(this);
                var len = parseInt(O.length) || 0;
                if (len === 0) {
                    return false;
                }
                var n = parseInt(arguments[1]) || 0;
                var k;
                if (n >= 0) {
                    k = n;
                } else {
                    k = len + n;
                    if (k < 0) {
                        k = 0;
                    }
                }
                function sameValueZero(x, y) {
                    return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
                }
                for (; k < len; k++) {
                    if (sameValueZero(O[k], searchElement)) {
                        return true;
                    }
                }
                return false;
            };
        }
        
        // Fetch polyfill using XMLHttpRequest (for old browsers)
        if (!supportsFetch) {
            window.fetch = function(url, options) {
                return new Promise(function(resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    var method = (options && options.method) || 'GET';
                    var headers = (options && options.headers) || {};
                    var body = options && options.body;
                    
                    xhr.open(method, url);
                    
                    for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                            xhr.setRequestHeader(key, headers[key]);
                        }
                    }
                    
                    xhr.onload = function() {
                        var response = {
                            ok: xhr.status >= 200 && xhr.status < 300,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: function() {
                                return Promise.resolve(JSON.parse(xhr.responseText));
                            },
                            text: function() {
                                return Promise.resolve(xhr.responseText);
                            }
                        };
                        if (response.ok) {
                            resolve(response);
                        } else {
                            reject(new Error('HTTP ' + xhr.status + ': ' + xhr.statusText));
                        }
                    };
                    
                    xhr.onerror = function() {
                        reject(new Error('Network error'));
                    };
                    
                    xhr.send(body);
                });
            };
        }
        
        var cityInput = document.getElementById('city-input');
        var stateInput = document.getElementById('state-input');
        var countrySelect = document.getElementById('country-select');
        var countryInput = document.getElementById('country-input');
        var countryDropdown = document.getElementById('country-dropdown');
        var citySuggestions = document.getElementById('city-suggestions');
        var searchBtn = document.getElementById('search-btn');
        var formatFilter = document.getElementById('format-filter');
        var languageFilter = document.getElementById('language-filter');
        var container = document.getElementById('showtimes-container');
        
        // Debug: Check if elements are found
        if (!cityInput) {
            console.error('city-input not found');
        } else {
            console.log('‚úì city-input found');
        }
        if (!countryInput) {
            console.error('country-input not found');
        } else {
            console.log('‚úì country-input found');
        }
        if (!citySuggestions) {
            console.error('city-suggestions not found');
        } else {
            console.log('‚úì city-suggestions found');
        }
        if (!countryDropdown) {
            console.error('country-dropdown not found');
        } else {
            console.log('‚úì country-dropdown found');
        }
        
        // Verify fetch is available
        if (typeof fetch === 'undefined') {
            console.error('fetch is not available - polyfill may not have loaded');
        } else {
            console.log('‚úì fetch is available');
        }
        
        // For old devices: Show native select instead of custom dropdown
        // Since we have polyfills for fetch, only check for async/await support
        // But allow custom dropdowns even on old devices since we've converted everything to ES5
        var useNativeSelect = false; // Always use custom dropdowns - they work with polyfills
        if (useNativeSelect) {
            // Hide custom country input, show native select
            if (countryInput && countryInput.parentElement) {
                countryInput.parentElement.style.display = 'none';
            }
            if (countrySelect) {
                countrySelect.style.display = 'block';
            }
        } else {
            // Ensure custom dropdowns are visible
            if (countryInput && countryInput.parentElement) {
                countryInput.parentElement.style.display = '';
            }
            if (countrySelect) {
                countrySelect.style.display = 'none'; // Hide native select, use custom
            }
        }
        
        var currentCity = null;
        var currentCountry = null;
        var showtimes = [];
        var pollingInterval = null;
        var autocompleteTimeout = null;
        var skeletonTimeout = null;
        
        // Check if we're in a secure context (HTTPS required for geolocation)
        function isSecureContext() {
            return window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        }
        
        // Request browser geolocation and reverse geocode
        function requestLocationAndGeocode(showManualButton) {
            if (showManualButton === undefined) showManualButton = false;
            if (!navigator.geolocation) {
                console.log('Geolocation is not supported by this browser');
                return;
            }
            
            // Check if we're in a secure context
            if (!isSecureContext()) {
                console.warn('Geolocation requires HTTPS. Current protocol:', location.protocol);
                // Don't show error on initial load, only if manually triggered
                if (showManualButton) {
                    showLocationError('Geolocation requires HTTPS. Please access this site over HTTPS (https://) to use location detection.');
                }
                return;
            }
            
            // Show a subtle indicator that we're requesting location
            var locationIndicator = document.createElement('div');
            locationIndicator.id = 'location-request-indicator';
            locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
            locationIndicator.textContent = 'üìç Requesting location...';
            document.body.appendChild(locationIndicator);
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    var lat = position.coords.latitude;
                    var lon = position.coords.longitude;
                    
                    // Reverse geocode coordinates to get city/country
                    fetch('/api/geocode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ lat: lat, lon: lon })
                    }).then(function(response) {
                        return response.json();
                    }).then(function(data) {
                        if (data.success && data.city && data.country) {
                            // Set city
                            cityInput.value = data.city;
                            if (data.region) {
                                if (cityInput.dataset) {
                                    cityInput.dataset.state = data.region;
                                } else {
                                    cityInput.setAttribute('data-state', data.region);
                                }
                                stateInput.value = data.region;
                            }
                            
                            // Set country
                            var countryName = data.country;
                            countryInput.value = countryName;
                            
                            // Find and select the country in the dropdown
                            var countryOption = null;
                            var options = Array.from ? Array.from(countrySelect.options) : [];
                            if (!Array.from) {
                                // Fallback for old browsers
                                for (var i = 0; i < countrySelect.options.length; i++) {
                                    options.push(countrySelect.options[i]);
                                }
                            }
                            
                            for (var j = 0; j < options.length; j++) {
                                var opt = options[j];
                                if (opt.textContent.trim() === countryName) {
                                    countryOption = opt;
                                    break;
                                }
                            }
                            
                            if (!countryOption) {
                                for (var k = 0; k < options.length; k++) {
                                    var opt2 = options[k];
                                    if (opt2.textContent.trim().toLowerCase() === countryName.toLowerCase()) {
                                        countryOption = opt2;
                                        break;
                                    }
                                }
                            }
                            
                            if (!countryOption) {
                                for (var m = 0; m < options.length; m++) {
                                    var opt3 = options[m];
                                    var optText = opt3.textContent.trim().toLowerCase();
                                    var countryLower = countryName.toLowerCase();
                                    if (optText.indexOf(countryLower) !== -1 || countryLower.indexOf(optText) !== -1) {
                                        countryOption = opt3;
                                        break;
                                    }
                                }
                            }
                            
                            if (countryOption) {
                                countrySelect.value = countryOption.value;
                            }
                            
                            // Show auto-detected badge
                            var badge = document.getElementById('auto-detected-badge');
                            if (badge) {
                                badge.style.display = 'inline-block';
                            }
                            
                            // Update indicator
                            locationIndicator.textContent = '‚úì Location detected';
                            locationIndicator.style.background = 'rgba(39, 174, 96, 0.9)';
                            setTimeout(function() {
                                locationIndicator.remove();
                            }, 2000);
                        } else {
                            // Browser geolocation succeeded but geocoding failed - fallback to IP
                            locationIndicator.textContent = 'üìç Trying IP-based location...';
                            requestLocationFromIP();
                        }
                    }).catch(function(error) {
                        console.error('Geocoding error:', error);
                        // Geocoding failed - fallback to IP
                        locationIndicator.textContent = 'üìç Trying IP-based location...';
                        requestLocationFromIP();
                    });
                },
                function(error) {
                    // User denied or error occurred - always try IP-based fallback
                    locationIndicator.textContent = 'üìç Trying IP-based location...';
                    locationIndicator.style.background = 'rgba(52, 152, 219, 0.9)';
                    requestLocationFromIP();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0  // Don't use cached position
                }
            );
        }
        
        // Helper function to show location error
        function showLocationError(message) {
            var locationIndicator = document.createElement('div');
            locationIndicator.id = 'location-request-indicator';
            locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(231, 76, 60, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 350px;';
            locationIndicator.textContent = '‚ö† ' + message;
            document.body.appendChild(locationIndicator);
            setTimeout(function() {
                locationIndicator.remove();
            }, 5000);
        }
        
        // IP-based geolocation fallback (no permission needed, works automatically)
        function requestLocationFromIP() {
            // Check if indicator already exists (from previous attempt)
            var locationIndicator = document.getElementById('location-request-indicator');
            if (!locationIndicator) {
                locationIndicator = document.createElement('div');
                locationIndicator.id = 'location-request-indicator';
                locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
                locationIndicator.textContent = 'üìç Detecting location...';
                document.body.appendChild(locationIndicator);
            } else {
                locationIndicator.textContent = 'üìç Detecting location...';
            }
            
            fetch('/api/geocode-ip').then(function(response) {
                return response.json();
            }).then(function(data) {
                if (data.success && data.city && data.country) {
                    // Set city
                    cityInput.value = data.city;
                    if (data.region) {
                        if (cityInput.dataset) {
                            cityInput.dataset.state = data.region;
                        } else {
                            cityInput.setAttribute('data-state', data.region);
                        }
                        stateInput.value = data.region;
                    }
                    
                    // Set country
                    var countryName = data.country;
                    countryInput.value = countryName;
                    
                    // Find and select the country in the dropdown
                    var countryOption = null;
                    var options = Array.from ? Array.from(countrySelect.options) : [];
                    if (!Array.from) {
                        // Fallback for old browsers
                        for (var i = 0; i < countrySelect.options.length; i++) {
                            options.push(countrySelect.options[i]);
                        }
                    }
                    
                    for (var j = 0; j < options.length; j++) {
                        var opt = options[j];
                        if (opt.textContent.trim() === countryName) {
                            countryOption = opt;
                            break;
                        }
                    }
                    
                    if (!countryOption) {
                        for (var k = 0; k < options.length; k++) {
                            var opt2 = options[k];
                            if (opt2.textContent.trim().toLowerCase() === countryName.toLowerCase()) {
                                countryOption = opt2;
                                break;
                            }
                        }
                    }
                    
                    if (!countryOption) {
                        for (var m = 0; m < options.length; m++) {
                            var opt3 = options[m];
                            var optText = opt3.textContent.trim().toLowerCase();
                            var countryLower = countryName.toLowerCase();
                            if (optText.indexOf(countryLower) !== -1 || countryLower.indexOf(optText) !== -1) {
                                countryOption = opt3;
                                break;
                            }
                        }
                    }
                    
                    if (countryOption) {
                        countrySelect.value = countryOption.value;
                    }
                    
                    // Show auto-detected badge
                    var badge = document.getElementById('auto-detected-badge');
                    if (badge) {
                        badge.style.display = 'inline-block';
                    }
                    
                    // Update indicator
                    locationIndicator.textContent = '‚úì Location detected';
                    locationIndicator.style.background = 'rgba(39, 174, 96, 0.9)';
                    setTimeout(function() {
                        locationIndicator.remove();
                    }, 2000);
                } else {
                    // Silently remove indicator if no location found
                    locationIndicator.remove();
                }
            }).catch(function(error) {
                console.error('IP geolocation error:', error);
                // Silently remove indicator on error
                locationIndicator.remove();
            });
        }
        
        // Auto-detect location on page load: Try browser geolocation first, fallback to IP
        function autoDetectLocation() {
            // Check if browser geolocation is available and we're in a secure context
            if (navigator.geolocation && isSecureContext()) {
                // Try browser geolocation first (more accurate)
                var locationIndicator = document.createElement('div');
                locationIndicator.id = 'location-request-indicator';
                locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
                locationIndicator.textContent = 'üìç Detecting location...';
                document.body.appendChild(locationIndicator);
                
                // Try browser geolocation with a short timeout
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        // Browser geolocation succeeded - remove indicator and let requestLocationAndGeocode handle it
                        locationIndicator.remove();
                        requestLocationAndGeocode(false);
                    },
                    function(error) {
                        // Browser geolocation failed - fallback to IP
                        locationIndicator.textContent = 'üìç Trying IP-based location...';
                        requestLocationFromIP();
                    },
                    {
                        enableHighAccuracy: false,  // Faster, less accurate is fine for initial detection
                        timeout: 5000,  // Short timeout - fallback quickly to IP
                        maximumAge: 60000  // Accept cached position up to 1 minute old
                    }
                );
            } else {
                // Browser geolocation not available or not in secure context - use IP directly
                requestLocationFromIP();
            }
        }
        
        // Auto-detect location on page load - wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(autoDetectLocation, 500);
            });
        } else {
            // DOM is already ready
            setTimeout(autoDetectLocation, 500);
        }
        
        // Add manual location button next to city input (for precise GPS location)
        var cityGroup = document.querySelector('.city-group');
        if (cityGroup) {
            var locationButton = document.createElement('button');
            locationButton.type = 'button';
            locationButton.id = 'manual-location-btn';
            locationButton.innerHTML = 'üìç';
            locationButton.title = 'Use precise GPS location (requires permission)';
            locationButton.setAttribute('aria-label', 'Use precise GPS location');
            locationButton.addEventListener('click', function() {
                if (!navigator.geolocation) {
                    showLocationError('Geolocation is not supported by your browser.');
                    return;
                }
                if (!isSecureContext()) {
                    showLocationError('Precise GPS location requires HTTPS. Please access this site over HTTPS (https://).');
                    return;
                }
                requestLocationAndGeocode(true);
            });
            
            var locationInputGroup = cityGroup.querySelector('.location-input-group');
            if (locationInputGroup) {
                locationInputGroup.appendChild(locationButton);
            }
        }
        
        // Clear auto-detected location when badge is clicked
        var autoDetectedBadge = document.getElementById('auto-detected-badge');
        if (autoDetectedBadge) {
            autoDetectedBadge.addEventListener('click', function() {
                // Clear city, state, and country inputs
                cityInput.value = '';
                stateInput.value = '';
                countryInput.value = '';
                countrySelect.value = '';
                delete cityInput.dataset.state;
                
                // Hide the badge
                autoDetectedBadge.style.display = 'none';
                
                // Focus on city input for user to type
                cityInput.focus();
            });
        }
        
        // Comprehensive country list (ISO 3166-1)
        var countries = [
            "Afghanistan", "Albania", "Algeria", "Andorra", "Angola", "Argentina", "Armenia", 
            "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", 
            "Belarus", "Belgium", "Belize", "Benin", "Bhutan", "Bolivia", "Bosnia and Herzegovina", 
            "Botswana", "Brazil", "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", 
            "Cameroon", "Canada", "Cape Verde", "Central African Republic", "Chad", "Chile", 
            "China", "Colombia", "Comoros", "Congo", "Costa Rica", "Croatia", "Cuba", "Cyprus", 
            "Czech Republic", "Denmark", "Djibouti", "Dominican Republic", "Ecuador", "Egypt", 
            "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Eswatini", "Ethiopia", 
            "Fiji", "Finland", "France", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", 
            "Greece", "Grenada", "Guatemala", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", 
            "Honduras", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", 
            "Israel", "Italy", "Ivory Coast", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", 
            "Kiribati", "Kuwait", "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia", 
            "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Madagascar", "Malawi", "Malaysia", 
            "Maldives", "Mali", "Malta", "Mauritania", "Mauritius", "Mexico", "Moldova", "Monaco", 
            "Mongolia", "Montenegro", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", 
            "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Niger", "Nigeria", "North Korea", 
            "North Macedonia", "Norway", "Oman", "Pakistan", "Palau", "Palestine", "Panama", 
            "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Qatar", 
            "Romania", "Russia", "Rwanda", "Saint Lucia", "Samoa", "San Marino", "Saudi Arabia", 
            "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", 
            "Solomon Islands", "Somalia", "South Africa", "South Korea", "South Sudan", "Spain", 
            "Sri Lanka", "Sudan", "Suriname", "Sweden", "Switzerland", "Syria", "Taiwan", 
            "Tajikistan", "Tanzania", "Thailand", "Timor-Leste", "Togo", "Tonga", "Trinidad and Tobago", 
            "Tunisia", "Turkey", "Turkmenistan", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", 
            "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican City", 
            "Venezuela", "Vietnam", "Yemen", "Zambia", "Zimbabwe"
        ];
        
        // Populate country dropdown (hidden select for form submission, or visible for old devices)
        for (var i = 0; i < countries.length; i++) {
            var country = countries[i];
            var option = document.createElement('option');
            option.value = country;
            option.textContent = country;
            if (countrySelect) {
                countrySelect.appendChild(option);
            }
        }
        
        // Country search functionality (only for modern browsers)
        if (!useNativeSelect && countryInput) {
            console.log('‚úì Country input event listener attached');
            var countrySearchTimeout = null;
            countryInput.addEventListener('input', function(e) {
                console.log('Country input event triggered, value:', e.target.value);
                var query = e.target.value.trim().toLowerCase();
                
                if (countrySearchTimeout) {
                    clearTimeout(countrySearchTimeout);
                }
                
                // Reset selection when input changes
                selectedCountryIndex = -1;
                
                if (query.length === 0) {
                    countryDropdown.classList.remove('show');
                    countrySelect.value = '';
                    selectedCountryIndex = -1;
                    return;
                }
                
                countrySearchTimeout = setTimeout(function() {
                    var filtered = [];
                    for (var i = 0; i < countries.length; i++) {
                        if (countries[i].toLowerCase().indexOf(query) !== -1) {
                            filtered.push(countries[i]);
                            if (filtered.length >= 10) break; // Limit to 10 results
                        }
                    }
                    
                    countryDropdown.innerHTML = '';
                    if (filtered.length === 0) {
                        countryDropdown.classList.remove('show');
                        return;
                    }
                    
                    for (var j = 0; j < filtered.length; j++) {
                        var country = filtered[j];
                        var div = document.createElement('div');
                        div.className = 'country-option';
                        div.textContent = country;
                        
                        // Function to select this country (used by both click and keyboard)
                        var selectCountry = function(countryName) {
                            return function() {
                                countryInput.value = countryName;
                                countrySelect.value = countryName;
                                countryDropdown.classList.remove('show');
                                selectedCountryIndex = -1; // Reset selection
                            };
                        }(country);
                        
                        div.addEventListener('click', selectCountry);
                        countryDropdown.appendChild(div);
                    }
                    
                    countryDropdown.classList.add('show');
                    selectedCountryIndex = -1; // Reset selection when new suggestions are shown
                }, 200);
            });
        }
        
        // Keyboard navigation for country suggestions
        countryInput.addEventListener('keydown', function(e) {
            var countryOptions = countryDropdown.querySelectorAll('.country-option');
            
            if (!countryDropdown.classList.contains('show') || countryOptions.length === 0) {
                // If suggestions are not visible, allow Enter key to work normally
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedCountryIndex = (selectedCountryIndex + 1) % countryOptions.length;
                    updateCountrySelection(countryOptions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedCountryIndex = selectedCountryIndex <= 0 
                        ? countryOptions.length - 1 
                        : selectedCountryIndex - 1;
                    updateCountrySelection(countryOptions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedCountryIndex >= 0 && selectedCountryIndex < countryOptions.length) {
                        countryOptions[selectedCountryIndex].click();
                    } else {
                        // If no selection, close dropdown
                        countryDropdown.classList.remove('show');
                        selectedCountryIndex = -1;
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    countryDropdown.classList.remove('show');
                    selectedCountryIndex = -1;
                    break;
            }
        });
        
        // Allow selecting from native select (for old browsers and keyboard users)
        if (countrySelect) {
            countrySelect.addEventListener('change', function(e) {
                if (e.target.value && !useNativeSelect && countryInput) {
                    countryInput.value = e.target.value;
                }
            });
        }
        
        // City autocomplete using OpenStreetMap Nominatim (free API)
        if (cityInput) {
            console.log('‚úì City input event listener attached');
            cityInput.addEventListener('input', function(e) {
                console.log('City input event triggered, value:', e.target.value);
                var query = e.target.value.trim();
                
                // Clear previous timeout
                if (autocompleteTimeout) {
                    clearTimeout(autocompleteTimeout);
                }
                
                if (query.length < 2) {
                    if (citySuggestions) {
                        citySuggestions.classList.remove('show');
                    }
                    return;
                }
                
                // Debounce API calls (500ms delay)
                autocompleteTimeout = setTimeout(function() {
                    console.log('Calling fetchCitySuggestions for:', query);
                    fetchCitySuggestions(query);
                }, 500);
            });
        } else {
            console.error('City input not found - cannot attach event listener');
        }
        
        function fetchCitySuggestions(query) {
            if (!citySuggestions) {
                console.error('City suggestions element not found');
                return;
            }
            
            // Search globally - don't restrict by country
            // Request address details for better structured data
            // Remove featuretype=city restriction to get all city-like places (cities, towns, villages, etc.)
            // This ensures we get results for major cities like Los Angeles, New York, etc.
            var url = 'https://nominatim.openstreetmap.org/search?q=' + encodeURIComponent(query) + '&format=json&limit=10&addressdetails=1&extratags=1';
            
            // Note: We intentionally don't use countrycodes parameter here to allow global city search
            // The country selection is only used when submitting the search, not for autocomplete
            // This allows users to search for any city worldwide regardless of country filter
            
            console.log('Fetching city suggestions for:', query);
            
            fetch(url, {
                headers: { 
                    'Accept-Language': '{{ lang }}',
                    'User-Agent': 'CineStream/1.0' // Required by Nominatim
                }
            }).then(function(response) {
                if (!response.ok) {
                    console.error('Nominatim API error:', response.status, response.statusText);
                    if (citySuggestions) {
                        citySuggestions.classList.remove('show');
                    }
                    return null;
                }
                return response.json();
            }).then(function(results) {
                if (!results || results.length === 0) {
                    console.log('No results from Nominatim');
                    if (citySuggestions) {
                        citySuggestions.classList.remove('show');
                    }
                    return;
                }
                
                console.log('Received', results.length, 'results from Nominatim');
                
                // Filter results to prioritize cities, towns, and municipalities
                // But include other place types if they're the best match
                var filteredResults = [];
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    var placeType = result.type || '';
                    var placeClass = result.class || '';
                    var shouldInclude = false;
                    
                    // Include cities, towns, villages, municipalities, and administrative areas
                    if (placeType.indexOf('city') !== -1 || 
                        placeType.indexOf('town') !== -1 || 
                        placeType.indexOf('village') !== -1 || 
                        placeType.indexOf('municipality') !== -1 ||
                        placeType.indexOf('administrative') !== -1 ||
                        placeClass === 'place' ||
                        (result.address && (result.address.city || result.address.town || result.address.village || result.address.municipality))) {
                        shouldInclude = true;
                    }
                    
                    if (shouldInclude) {
                        filteredResults.push(result);
                        if (filteredResults.length >= 5) break; // Limit to 5 results
                    }
                }
                
                var displayResults = filteredResults.length > 0 ? filteredResults : results.slice(0, 5);
                console.log('Displaying', displayResults.length, 'city suggestions');
                displayCitySuggestions(displayResults);
            }).catch(function(e) {
                console.error('Autocomplete error:', e);
                console.error('Error details:', e.message, e.stack);
                if (citySuggestions) {
                    citySuggestions.classList.remove('show');
                }
            });
        }
        
        function displayCitySuggestions(results) {
            if (!citySuggestions) {
                console.error('City suggestions element not found in displayCitySuggestions');
                return;
            }
            
            console.log('displayCitySuggestions called with', results.length, 'results');
            
            if (results.length === 0) {
                console.log('No results to display, hiding suggestions');
                citySuggestions.classList.remove('show');
                selectedSuggestionIndex = -1;
                return;
            }
            
            citySuggestions.innerHTML = '';
            selectedSuggestionIndex = -1; // Reset selection when new suggestions are shown
            
            console.log('Creating', results.length, 'suggestion items');
            
            for (var i = 0; i < results.length; i++) {
                var result = results[i];
                var div = document.createElement('div');
                div.className = 'suggestion-item';
                
                // Extract city, state, and country from Nominatim API response
                // Prefer structured address object over parsing display_name
                var cityName = '';
                var stateName = '';
                var countryName = '';
                
                if (result.address) {
                    // Use structured address data (more reliable)
                    cityName = result.address.city || 
                              result.address.town || 
                              result.address.village || 
                              result.address.municipality ||
                              result.address.county ||
                              '';
                    
                    // State/province can be in different fields
                    stateName = result.address.state || 
                               result.address.province || 
                               result.address.region ||
                               result.address.state_district ||
                               '';
                    
                    countryName = result.address.country || '';
                }
                
                // Fallback to parsing display_name if address object is incomplete
                if (!cityName || !countryName) {
                    var parts = result.display_name.split(', ');
                    if (!cityName) {
                        cityName = parts[0];
                    }
                    if (!countryName) {
                        countryName = parts[parts.length - 1];
                    }
                    if (!stateName && parts.length >= 3) {
                        stateName = parts.slice(1, -1).join(', ');
                    }
                }
                
                // Clean up extracted values
                cityName = cityName.trim();
                stateName = stateName.trim();
                countryName = countryName.trim();
                
                // Build display text
                var displayText = cityName;
                if (stateName) {
                    displayText += ' <small>(' + stateName + ', ' + countryName + ')</small>';
                } else {
                    displayText += ' <small>(' + countryName + ')</small>';
                }
                
                div.innerHTML = displayText;
                
                // Store full location data in data attributes
                div.setAttribute('data-city', cityName);
                div.setAttribute('data-state', stateName);
                div.setAttribute('data-country', countryName);
                
                // Function to select this suggestion (used by both click and keyboard)
                var selectSuggestion = (function(city, state, country) {
                    return function() {
                        // Set state in dataset and input FIRST to prevent input event listener from clearing it
                        if (state && state.length > 0) {
                            if (cityInput.dataset) {
                                cityInput.dataset.state = state;
                            } else {
                                cityInput.setAttribute('data-state', state);
                            }
                            stateInput.value = state;
                        } else {
                            if (cityInput.dataset) {
                                delete cityInput.dataset.state;
                            } else {
                                cityInput.removeAttribute('data-state');
                            }
                            stateInput.value = '';
                        }
                        
                        // Set city name (this will trigger input event, but dataset.state is already set)
                        cityInput.value = city;
                        
                        // Try to match and select the country
                        // First, normalize country name (remove common suffixes, handle abbreviations)
                        function normalizeCountryName(name) {
                            return name.toLowerCase()
                                .replace(/\s+/g, ' ')
                                .trim();
                        }
                        
                        var countryLower = normalizeCountryName(country);
                    
                    // Common country name mappings (API might return different names)
                    var countryMappings = {
                        'usa': 'United States',
                        'us': 'United States',
                        'united states of america': 'United States',
                        'united states': 'United States',
                        'uk': 'United Kingdom',
                        'united kingdom': 'United Kingdom',
                        'united kingdom of great britain and northern ireland': 'United Kingdom',
                        'russian federation': 'Russia',
                        'russia': 'Russia',
                        'czechia': 'Czech Republic',
                        'czech republic': 'Czech Republic',
                        'myanmar': 'Myanmar',
                        'burma': 'Myanmar',
                        'east timor': 'Timor-Leste',
                        'timor-leste': 'Timor-Leste',
                        'swaziland': 'Eswatini',
                        'eswatini': 'Eswatini',
                        'macedonia': 'North Macedonia',
                        'north macedonia': 'North Macedonia',
                        'c√¥te d\'ivoire': 'Ivory Coast',
                        'cote d\'ivoire': 'Ivory Coast',
                        'ivory coast': 'Ivory Coast',
                        'south korea': 'South Korea',
                        'republic of korea': 'South Korea',
                        'north korea': 'North Korea',
                        'democratic people\'s republic of korea': 'North Korea',
                        'dprk': 'North Korea'
                    };
                    
                    // Check mappings first
                    var matchedCountry = null;
                    if (countryMappings[countryLower]) {
                        matchedCountry = countryMappings[countryLower];
                    } else {
                        // Try exact match
                        for (var cIdx = 0; cIdx < countries.length; cIdx++) {
                            var c = countries[cIdx];
                            var cLower = normalizeCountryName(c);
                            if (cLower === countryLower) {
                                matchedCountry = c;
                                break;
                            }
                        }
                        
                        // Try contains match (either direction)
                        if (!matchedCountry) {
                            for (var cIdx2 = 0; cIdx2 < countries.length; cIdx2++) {
                                var c2 = countries[cIdx2];
                                var cLower2 = normalizeCountryName(c2);
                                if (countryLower.indexOf(cLower2) !== -1 || cLower2.indexOf(countryLower) !== -1) {
                                    matchedCountry = c2;
                                    break;
                                }
                            }
                        }
                        
                        // Try word-based matching for multi-word countries
                        if (!matchedCountry) {
                            var countryWords = countryLower.split(/\s+/);
                            var filteredWords = [];
                            for (var wIdx = 0; wIdx < countryWords.length; wIdx++) {
                                if (countryWords[wIdx].length > 2) {
                                    filteredWords.push(countryWords[wIdx]);
                                }
                            }
                            for (var cIdx3 = 0; cIdx3 < countries.length; cIdx3++) {
                                var c3 = countries[cIdx3];
                                var cLower3 = normalizeCountryName(c3);
                                var cWords = cLower3.split(/\s+/);
                                var foundMatch = false;
                                for (var wIdx2 = 0; wIdx2 < filteredWords.length; wIdx2++) {
                                    for (var cwIdx = 0; cwIdx < cWords.length; cwIdx++) {
                                        if (filteredWords[wIdx2] === cWords[cwIdx] || cWords[cwIdx] === filteredWords[wIdx2]) {
                                            matchedCountry = c3;
                                            foundMatch = true;
                                            break;
                                        }
                                    }
                                    if (foundMatch) break;
                                }
                                if (foundMatch) break;
                            }
                        }
                    }
                    
                    // Always set the country - try to match first, then use the country name from API
                    if (matchedCountry) {
                        // Update both the hidden select and visible input with matched country
                        countrySelect.value = matchedCountry;
                        countryInput.value = matchedCountry;
                        console.log('‚úì Country matched: "' + countryName + '" -> "' + matchedCountry + '"');
                    } else {
                        // If no match found, try to find the closest match or set as-is
                        // First, try to find by first word (e.g., "United" for "United States")
                        var firstWord = countryLower.split(/\s+/)[0];
                        var partialMatch = null;
                        for (var pIdx = 0; pIdx < countries.length; pIdx++) {
                            var pc = countries[pIdx];
                            var pcLower = normalizeCountryName(pc);
                            if (pcLower.indexOf(firstWord) === 0 || (firstWord.length > 3 && pcLower.indexOf(firstWord) !== -1)) {
                                partialMatch = pc;
                                break;
                            }
                        }
                        
                        if (partialMatch) {
                            countrySelect.value = partialMatch;
                            countryInput.value = partialMatch;
                            console.log('‚úì Country partially matched: "' + countryName + '" -> "' + partialMatch + '"');
                        } else {
                            // Set the country name as-is in the input (user can verify/correct)
                            countryInput.value = countryName;
                            // Try to find similar countries for user reference
                            var similar = [];
                            var sub3 = countryLower.substring(0, 3);
                            for (var sIdx = 0; sIdx < countries.length && similar.length < 3; sIdx++) {
                                var sc = countries[sIdx];
                                var scLower = normalizeCountryName(sc);
                                if (scLower.indexOf(sub3) !== -1 || sub3.indexOf(scLower.substring(0, 3)) !== -1) {
                                    similar.push(sc);
                                }
                            }
                            
                            console.warn(`‚ö† Could not match country "${countryName}" to country list`);
                            if (similar.length > 0) {
                                console.log(`   Similar countries found: ${similar.join(', ')}`);
                                // Auto-select the first similar country if very close match
                                if (similar.length === 1 || countryLower.length <= 5) {
                                    countrySelect.value = similar[0];
                                    countryInput.value = similar[0];
                                    console.log(`   Auto-selected closest match: "${similar[0]}"`);
                                }
                            }
                        }
                    }
                    
                    // Ensure country is always set (fallback to countryName if nothing else worked)
                    if (!countryInput.value || countryInput.value.trim() === '') {
                        countryInput.value = countryName;
                        console.log('   Set country to API value: "' + countryName + '"');
                    }
                    
                    // State is already set above before cityInput.value was set
                    if (stateName && stateName.length > 0) {
                        console.log('‚úì State stored: "' + stateName + '"');
                    }
                    
                        // Log summary for debugging
                        console.log('Selected location: City="' + cityName + '", State="' + (stateName || '(none)') + '", Country="' + (matchedCountry || countryName) + '"');
                        
                        // Close suggestions
                        citySuggestions.classList.remove('show');
                        selectedSuggestionIndex = -1;
                    };
                }(cityName, stateName, countryName));
                
                div.addEventListener('click', selectSuggestion);
                
                citySuggestions.appendChild(div);
            }
            
            // Show the suggestions dropdown
            console.log('Showing suggestions dropdown');
            citySuggestions.classList.add('show');
            console.log('Suggestions dropdown should now be visible');
        }
        
        // Complete ISO 3166-1 alpha-2 country codes for Nominatim (matches all countries in list)
        function getCountryCode(countryName) {
            var codes = {
                "Afghanistan": "af", "Albania": "al", "Algeria": "dz", "Andorra": "ad", 
                "Angola": "ao", "Argentina": "ar", "Armenia": "am", "Australia": "au", 
                "Austria": "at", "Azerbaijan": "az", "Bahamas": "bs", "Bahrain": "bh", 
                "Bangladesh": "bd", "Barbados": "bb", "Belarus": "by", "Belgium": "be", 
                "Belize": "bz", "Benin": "bj", "Bhutan": "bt", "Bolivia": "bo", 
                "Bosnia and Herzegovina": "ba", "Botswana": "bw", "Brazil": "br", 
                "Brunei": "bn", "Bulgaria": "bg", "Burkina Faso": "bf", "Burundi": "bi", 
                "Cambodia": "kh", "Cameroon": "cm", "Canada": "ca", "Cape Verde": "cv", 
                "Central African Republic": "cf", "Chad": "td", "Chile": "cl", "China": "cn", 
                "Colombia": "co", "Comoros": "km", "Congo": "cg", "Costa Rica": "cr", 
                "Croatia": "hr", "Cuba": "cu", "Cyprus": "cy", "Czech Republic": "cz", 
                "Denmark": "dk", "Djibouti": "dj", "Dominican Republic": "do", "Ecuador": "ec", 
                "Egypt": "eg", "El Salvador": "sv", "Equatorial Guinea": "gq", "Eritrea": "er", 
                "Estonia": "ee", "Eswatini": "sz", "Ethiopia": "et", "Fiji": "fj", 
                "Finland": "fi", "France": "fr", "Gabon": "ga", "Gambia": "gm", 
                "Georgia": "ge", "Germany": "de", "Ghana": "gh", "Greece": "gr", 
                "Grenada": "gd", "Guatemala": "gt", "Guinea": "gn", "Guinea-Bissau": "gw", 
                "Guyana": "gy", "Haiti": "ht", "Honduras": "hn", "Hungary": "hu", 
                "Iceland": "is", "India": "in", "Indonesia": "id", "Iran": "ir", 
                "Iraq": "iq", "Ireland": "ie", "Israel": "il", "Italy": "it", 
                "Ivory Coast": "ci", "Jamaica": "jm", "Japan": "jp", "Jordan": "jo", 
                "Kazakhstan": "kz", "Kenya": "ke", "Kiribati": "ki", "Kuwait": "kw", 
                "Kyrgyzstan": "kg", "Laos": "la", "Latvia": "lv", "Lebanon": "lb", 
                "Lesotho": "ls", "Liberia": "lr", "Libya": "ly", "Liechtenstein": "li", 
                "Lithuania": "lt", "Luxembourg": "lu", "Madagascar": "mg", "Malawi": "mw", 
                "Malaysia": "my", "Maldives": "mv", "Mali": "ml", "Malta": "mt", 
                "Mauritania": "mr", "Mauritius": "mu", "Mexico": "mx", "Moldova": "md", 
                "Monaco": "mc", "Mongolia": "mn", "Montenegro": "me", "Morocco": "ma", 
                "Mozambique": "mz", "Myanmar": "mm", "Namibia": "na", "Nauru": "nr", 
                "Nepal": "np", "Netherlands": "nl", "New Zealand": "nz", "Nicaragua": "ni", 
                "Niger": "ne", "Nigeria": "ng", "North Korea": "kp", "North Macedonia": "mk", 
                "Norway": "no", "Oman": "om", "Pakistan": "pk", "Palau": "pw", 
                "Palestine": "ps", "Panama": "pa", "Papua New Guinea": "pg", "Paraguay": "py", 
                "Peru": "pe", "Philippines": "ph", "Poland": "pl", "Portugal": "pt", 
                "Qatar": "qa", "Romania": "ro", "Russia": "ru", "Rwanda": "rw", 
                "Saint Lucia": "lc", "Samoa": "ws", "San Marino": "sm", "Saudi Arabia": "sa", 
                "Senegal": "sn", "Serbia": "rs", "Seychelles": "sc", "Sierra Leone": "sl", 
                "Singapore": "sg", "Slovakia": "sk", "Slovenia": "si", "Solomon Islands": "sb", 
                "Somalia": "so", "South Africa": "za", "South Korea": "kr", "South Sudan": "ss", 
                "Spain": "es", "Sri Lanka": "lk", "Sudan": "sd", "Suriname": "sr", 
                "Sweden": "se", "Switzerland": "ch", "Syria": "sy", "Taiwan": "tw", 
                "Tajikistan": "tj", "Tanzania": "tz", "Thailand": "th", "Timor-Leste": "tl", 
                "Togo": "tg", "Tonga": "to", "Trinidad and Tobago": "tt", "Tunisia": "tn", 
                "Turkey": "tr", "Turkmenistan": "tm", "Tuvalu": "tv", "Uganda": "ug", 
                "Ukraine": "ua", "United Arab Emirates": "ae", "United Kingdom": "gb", 
                "United States": "us", "Uruguay": "uy", "Uzbekistan": "uz", "Vanuatu": "vu", 
                "Vatican City": "va", "Venezuela": "ve", "Vietnam": "vn", "Yemen": "ye", 
                "Zambia": "zm", "Zimbabwe": "zw"
            };
            return codes[countryName] || '';
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!cityInput.contains(e.target) && !citySuggestions.contains(e.target)) {
                citySuggestions.classList.remove('show');
            }
        });
        
        // Validation function - verifies location exists using Nominatim API
        function validateLocationInput(city, country, state, callback) {
            if (!city || !country) {
                callback(['Please enter a city and select a country.']);
                return;
            }
            
            // Build search query
            var searchQuery = state && state.trim() ? city + ', ' + state + ', ' + country : city + ', ' + country;
            var url = 'https://nominatim.openstreetmap.org/search?q=' + encodeURIComponent(searchQuery) + '&format=json&limit=5&addressdetails=1&accept-language=en';
            
            fetch(url, {
                headers: { 
                    'User-Agent': 'CineStream/1.0',
                    'Accept': 'application/json'
                }
            }).then(function(response) {
                if (!response.ok) {
                    callback(['Unable to verify location. Please try again.']);
                    return;
                }
                return response.json();
            }).then(function(results) {
                if (!results || results.length === 0) {
                    callback(['Location not found. Please check the city, state, and country names.']);
                    return;
                }
                
                // Check if any result matches the location
                var cityLower = city.toLowerCase();
                var countryLower = country.toLowerCase();
                var stateLower = state ? state.toLowerCase() : '';
                var found = false;
                
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    var address = result.address || {};
                    var resultCity = (address.city || address.town || address.village || address.municipality || '').toLowerCase();
                    var resultCountry = (address.country || '').toLowerCase();
                    var resultState = (address.state || address.province || address.region || '').toLowerCase();
                    
                    // Check if country matches
                    if (resultCountry && resultCountry.indexOf(countryLower) === -1 && countryLower.indexOf(resultCountry) === -1) {
                        continue;
                    }
                    
                    // Check if city matches (fuzzy)
                    if (resultCity) {
                        if (resultCity.indexOf(cityLower) !== -1 || cityLower.indexOf(resultCity) !== -1) {
                            found = true;
                            break;
                        }
                        // Check if words match (e.g., "New York" matches "New York City")
                        var cityWords = cityLower.split(/\s+/);
                        var resultCityWords = resultCity.split(/\s+/);
                        var matchingWords = 0;
                        for (var j = 0; j < cityWords.length; j++) {
                            for (var k = 0; k < resultCityWords.length; k++) {
                                if (cityWords[j] === resultCityWords[k] && cityWords[j].length > 2) {
                                    matchingWords++;
                                    break;
                                }
                            }
                        }
                        if (matchingWords >= Math.min(cityWords.length, 2)) {
                            found = true;
                            break;
                        }
                    }
                }
                
                if (!found) {
                    callback(['Location not found. Please verify the city, state, and country are correct.']);
                } else {
                    callback([]); // No errors
                }
            }).catch(function(error) {
                console.error('Location validation error:', error);
                // Don't block on API errors - allow the request to proceed
                callback([]);
            });
        }
        
        // Search button click handler
        searchBtn.addEventListener('click', function() {
            var city = cityInput.value.trim();
            // Get country from select first, fallback to input if select is empty
            var country = countrySelect.value;
            if (!country && countryInput.value.trim()) {
                // If select is empty but input has value, try to match it
                var countryInputValue = countryInput.value.trim();
                var matchedOption = null;
                // Convert options to array (using polyfill if needed)
                var options = Array.from ? Array.from(countrySelect.options) : [];
                if (!Array.from) {
                    for (var i = 0; i < countrySelect.options.length; i++) {
                        options.push(countrySelect.options[i]);
                    }
                }
                // Find matching option
                for (var j = 0; j < options.length; j++) {
                    var opt = options[j];
                    if (opt.textContent.trim() === countryInputValue || opt.value === countryInputValue) {
                        matchedOption = opt;
                        break;
                    }
                }
                if (matchedOption) {
                    country = matchedOption.value;
                    countrySelect.value = country;
                } else {
                    // Use the input value directly if no match found
                    country = countryInputValue;
                }
            }
            // Get state from input field first, fallback to dataset
            var state = stateInput.value.trim() || (cityInput.dataset && cityInput.dataset.state) || '';
            
            // Hide suggestions
            citySuggestions.classList.remove('show');
            
            // Clear any existing polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            // Basic validation first
            if (!city) {
                showEmptyState('Please enter a city name', 'üèôÔ∏è');
                return;
            }
            
            if (!country) {
                showEmptyState('Please select a country', 'üåç');
                return;
            }
            
            // Show loading state while validating location
            showLoadingState('Verifying location...');
            
            // Validate location exists using API (async)
            validateLocationInput(city, country, state, function(validationErrors) {
                hideLoadingOverlay();
                
                if (validationErrors.length > 0) {
                    var errorMessage = validationErrors.join('\n');
                    showErrorState(errorMessage, function() {
                        cityInput.focus();
                    });
                    return;
                }
                
                // Location is valid, proceed with search
                currentCity = city;
                currentCountry = country;
                
                showLoadingSkeleton();
                
                // First, check if data is already available before triggering a scrape
                var locationId = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
                
                // ALWAYS check status first to see if there's an error (even on second search)
                fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusResponse) {
                    if (statusResponse.ok) {
                        return statusResponse.json().then(function(statusData) {
                            // If status is error, show error immediately and STOP
                            if (statusData.status === 'error') {
                                hideLoadingOverlay();
                                var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                showErrorState(errorMsg, function() {
                                    // Retry will trigger a new scrape attempt
                                    fetchShowtimes(city, country, state);
                                });
                                return; // STOP here, don't continue
                            }
                            
                            // Only check for existing showtimes if status is not error
                            var params = 'city_name=' + encodeURIComponent(locationId);
                            if (formatFilter.value) params += '&format=' + encodeURIComponent(formatFilter.value);
                            if (languageFilter.value) params += '&language=' + encodeURIComponent(languageFilter.value);
                            
                            return fetch('/api/showtimes?' + params).then(function(existingDataResponse) {
                                return existingDataResponse.json().then(function(existingShowtimes) {
                                    // If we have showtimes available, display them immediately (no need to scrape)
                                    if (existingShowtimes && Array.isArray(existingShowtimes) && existingShowtimes.length > 0) {
                                        hideLoadingOverlay(); // Stop animation
                                        showtimes = applyFilters(existingShowtimes);
                                        renderShowtimes();
                                        return; // Data is available, no need to trigger scrape
                                    }
                                    
                                    // Data not available - trigger scraping
                                    fetchShowtimes(city, country, state);
                                });
                            }).catch(function(e) {
                                // If checking existing data fails, continue to scrape
                                console.log('Could not check existing data, proceeding with scrape...');
                                fetchShowtimes(city, country, state);
                            });
                        });
                    }
                }).catch(function(e) {
                    // If status check fails, log but continue (might be first time)
                    console.log('Status check failed, continuing...', e);
                    // Proceed with scraping
                    fetchShowtimes(city, country, state);
                });
            });
        
        // Keyboard navigation for city and country suggestions
        var selectedSuggestionIndex = -1;
        var selectedCountryIndex = -1;
        
        cityInput.addEventListener('keydown', function(e) {
            var suggestions = citySuggestions.querySelectorAll('.suggestion-item');
            
            if (!citySuggestions.classList.contains('show') || suggestions.length === 0) {
                // If suggestions are not visible, handle Enter key to search
                if (e.key === 'Enter') {
                    e.preventDefault();
                    citySuggestions.classList.remove('show');
                    searchBtn.click();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedSuggestionIndex = (selectedSuggestionIndex + 1) % suggestions.length;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedSuggestionIndex = selectedSuggestionIndex <= 0 
                        ? suggestions.length - 1 
                        : selectedSuggestionIndex - 1;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < suggestions.length) {
                        // Get the selected suggestion's data
                        var selectedItem = suggestions[selectedSuggestionIndex];
                        var cityName = selectedItem.dataset.city;
                        var stateName = selectedItem.dataset.state || '';
                        var countryName = selectedItem.dataset.country;
                        
                        // Set state in dataset and input FIRST to prevent input event listener from clearing it
                        if (stateName && stateName.length > 0) {
                            cityInput.dataset.state = stateName;
                            stateInput.value = stateName;
                        } else {
                            delete cityInput.dataset.state;
                            stateInput.value = '';
                        }
                        
                        // Set city name (this will trigger input event, but dataset.state is already set)
                        cityInput.value = cityName;
                        
                        // Use the same country matching logic as click handler
                        var normalizeCountryName = function(name) {
                            return name.toLowerCase()
                                .replace(/\s+/g, ' ')
                                .trim();
                        };
                        
                        var countryLower = normalizeCountryName(countryName);
                        
                        // Common country name mappings
                        var countryMappings = {
                            'usa': 'United States',
                            'us': 'United States',
                            'united states of america': 'United States',
                            'uk': 'United Kingdom',
                            'united kingdom of great britain and northern ireland': 'United Kingdom',
                            'russian federation': 'Russia',
                            'czechia': 'Czech Republic',
                            'myanmar': 'Myanmar',
                            'burma': 'Myanmar',
                            'east timor': 'Timor-Leste',
                            'swaziland': 'Eswatini',
                            'macedonia': 'North Macedonia',
                            'north macedonia': 'North Macedonia',
                            'c√¥te d\'ivoire': 'Ivory Coast',
                            'ivory coast': 'Ivory Coast'
                        };
                        
                        var matchedCountry = null;
                        if (countryMappings[countryLower]) {
                            matchedCountry = countryMappings[countryLower];
                        } else {
                            // Use Array.find polyfill if available
                            var foundCountry = null;
                            for (var i = 0; i < countries.length; i++) {
                                var c = countries[i];
                                var cLower = normalizeCountryName(c);
                                if (cLower === countryLower) {
                                    foundCountry = c;
                                    break;
                                }
                            }
                            matchedCountry = foundCountry;
                            
                            if (!matchedCountry) {
                                for (var j = 0; j < countries.length; j++) {
                                    var c2 = countries[j];
                                    var cLower2 = normalizeCountryName(c2);
                                    if (countryLower.indexOf(cLower2) !== -1 || cLower2.indexOf(countryLower) !== -1) {
                                        matchedCountry = c2;
                                        break;
                                    }
                                }
                            }
                            
                            if (!matchedCountry) {
                                var countryWords = [];
                                var words = countryLower.split(/\s+/);
                                for (var w = 0; w < words.length; w++) {
                                    if (words[w].length > 2) {
                                        countryWords.push(words[w]);
                                    }
                                }
                                for (var k = 0; k < countries.length; k++) {
                                    var c3 = countries[k];
                                    var cLower3 = normalizeCountryName(c3);
                                    var cWords = cLower3.split(/\s+/);
                                    var foundMatch = false;
                                    for (var wIdx = 0; wIdx < countryWords.length; wIdx++) {
                                        for (var cwIdx = 0; cwIdx < cWords.length; cwIdx++) {
                                            if (countryWords[wIdx] === cWords[cwIdx] || cWords[cwIdx] === countryWords[wIdx]) {
                                                matchedCountry = c3;
                                                foundMatch = true;
                                                break;
                                            }
                                        }
                                        if (foundMatch) break;
                                    }
                                    if (foundMatch) break;
                                }
                            }
                        }
                        
                        if (matchedCountry) {
                            countrySelect.value = matchedCountry;
                            countryInput.value = matchedCountry;
                        } else {
                            countryInput.value = countryName;
                            console.warn('Could not match country "' + countryName + '" to country list');
                        }
                        
                        // State is already set above before cityInput.value was set
                        
                        citySuggestions.classList.remove('show');
                        selectedSuggestionIndex = -1;
                    } else {
                        citySuggestions.classList.remove('show');
                        searchBtn.click();
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    citySuggestions.classList.remove('show');
                    selectedSuggestionIndex = -1;
                    break;
            }
        });
        
        function updateSuggestionSelection(suggestions) {
            for (var idx = 0; idx < suggestions.length; idx++) {
                var item = suggestions[idx];
                var index = idx;
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.classList.remove('selected');
                }
            }
        }
        
        // Clear state when city input changes manually
        cityInput.addEventListener('input', function(e) {
            if (!e.target.dataset.state) {
                // Only clear if user is typing (not from autocomplete selection)
                delete cityInput.dataset.state;
                stateInput.value = '';
            }
        });
        
        // Sync state input with dataset when manually changed
        stateInput.addEventListener('input', function(e) {
            var stateValue = e.target.value.trim();
            if (stateValue) {
                cityInput.dataset.state = stateValue;
            } else {
                delete cityInput.dataset.state;
            }
        });
        
        function fetchShowtimes(city, country, state) {
            if (!state) state = '';
            
            fetch('/api/scrape', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    city: city, 
                    country: country,
                    state: state
                })
            }).then(function(scrapeResponse) {
                // Check HTTP status first - if it's an error status, handle it
                if (!scrapeResponse.ok && scrapeResponse.status !== 202) {
                    // HTTP error (400, 500, etc.) - try to get error message from response
                    var errorMsg = 'An error occurred while fetching showtimes.';
                    return scrapeResponse.json().then(function(errorData) {
                        errorMsg = errorData.message || errorData.error_message || errorData.error || errorMsg;
                        hideLoadingOverlay();
                        showErrorState(errorMsg, function() {
                            fetchShowtimes(city, country, state);
                        });
                    }).catch(function(e) {
                        // If JSON parsing fails, use default message
                        errorMsg = 'Server error (' + scrapeResponse.status + '). Please check your API key configuration.';
                        hideLoadingOverlay();
                        showErrorState(errorMsg, function() {
                            fetchShowtimes(city, country, state);
                        });
                    });
                }
                
                return scrapeResponse.json().then(function(data) {
                    if (scrapeResponse.status === 202) {
                        // Scraping in progress by another request - start polling
                        var locationId = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
                        showLoadingState('Scraping showtimes');
                        startPolling(locationId);
                        return;
                    }
                    
                    // FIRST: Check for error status BEFORE checking showtimes
                    if (data.status === 'error') {
                        // Error occurred - stop animation and show error
                        hideLoadingOverlay();
                        var errorMsg = data.message || data.error_message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                        showErrorState(errorMsg, function() {
                            fetchShowtimes(city, country, state);
                        });
                        return;
                    }
                    
                    // If we get showtimes directly, render them immediately (stop animation)
                    if (data.showtimes && Array.isArray(data.showtimes) && data.showtimes.length > 0) {
                        hideLoadingOverlay(); // Stop animation immediately
                        showtimes = applyFilters(data.showtimes);
                        renderShowtimes();
                        return;
                    }
                    
                    // Check if response contains showtimes (even if empty array) - but only if not error
                    if (data.showtimes && Array.isArray(data.showtimes)) {
                        // Before showing empty showtimes, check status for errors
                        var locationId = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
                        fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusCheck) {
                            if (statusCheck.ok) {
                                return statusCheck.json().then(function(statusData) {
                                    if (statusData.status === 'error') {
                                        hideLoadingOverlay();
                                        var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                        showErrorState(errorMsg, function() {
                                            fetchShowtimes(city, country, state);
                                        });
                                        return;
                                    }
                                    
                                    // Use showtimes from response immediately! (stop animation)
                                    hideLoadingOverlay(); // Stop animation
                                    showtimes = applyFilters(data.showtimes);
                                    renderShowtimes();
                                });
                            }
                        }).catch(function(e) {
                            // If status check fails, continue with showtimes
                            console.log('Status check failed, continuing with showtimes...', e);
                            // Use showtimes from response immediately! (stop animation)
                            hideLoadingOverlay(); // Stop animation
                            showtimes = applyFilters(data.showtimes);
                            renderShowtimes();
                        });
                        return;
                    } else if (data.status === 'success' || data.status === 'fresh') {
                        // Fallback: fetch showtimes separately (shouldn't happen with new API)
                        var locationId2 = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
                        hideLoadingOverlay(); // Stop animation before loading
                        loadShowtimes(locationId2);
                    } else {
                        // If we get here and no showtimes, no success status, and no error status,
                        // it might be a processing state - start polling to check status
                        var locationId3 = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
                        showLoadingState('Processing request...');
                        startPolling(locationId3);
                    }
                });
            }).catch(function(e) {
                console.error('Scrape error:', e);
                // Stop animation on error
                hideLoadingOverlay();
                showErrorState('Error connecting to server. Please check your internet connection.', function() {
                    fetchShowtimes(city, country, state);
                });
            });
        }
        
        function startPolling(locationId) {
            var pollCount = 0;
            // Poll every 2 seconds for status updates
            pollingInterval = setInterval(function() {
                pollCount++;
                var dataLoaded = false;
                
                // FIRST: Check if showtimes are available (even during daily refresh)
                // Always try to load data first - if it exists, show it immediately
                var params = 'city_name=' + encodeURIComponent(locationId);
                if (formatFilter.value) params += '&format=' + encodeURIComponent(formatFilter.value);
                if (languageFilter.value) params += '&language=' + encodeURIComponent(languageFilter.value);
                
                // Fetch both showtimes and status in parallel
                fetch('/api/showtimes?' + params).then(function(testResponse) {
                    return testResponse.json();
                }).then(function(testShowtimes) {
                    // Also fetch status
                    return fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusResponse) {
                        return statusResponse.json().then(function(statusData) {
                            // If we got showtimes (even if daily refresh is running), display them immediately
                            // BUT: Check status first - if status is 'error', show error instead of empty state
                            if (testShowtimes && Array.isArray(testShowtimes)) {
                                // Check status to see if there was an error BEFORE checking showtimes
                                if (statusData.status === 'error') {
                                    clearInterval(pollingInterval);
                                    pollingInterval = null;
                                    hideLoadingOverlay();
                                    var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                    showErrorState(errorMsg, function() {
                                        var city = cityInput.value.trim();
                                        var country = countrySelect.value;
                                        var state = stateInput.value.trim() || (cityInput.dataset && cityInput.dataset.state) || '';
                                        if (city && country) {
                                            fetchShowtimes(city, country, state);
                                        }
                                    });
                                    return;
                                }
                                
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                hideLoadingOverlay(); // Stop animation immediately
                                if (testShowtimes.length > 0) {
                                    showtimes = applyFilters(testShowtimes);
                                    renderShowtimes(); // Display available data
                                } else {
                                    // Data is ready but no showtimes found (only if not error status)
                                    showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                                }
                                return; // Exit, don't continue polling
                            }
                            
                            // If data was loaded, we already returned above
                            // Now check status for fresh/ready data
                            if (statusData.status === 'fresh' || statusData.ready) {
                                // Data is ready! Stop polling and load showtimes immediately
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                hideLoadingOverlay(); // Stop animation before loading
                                loadShowtimes(locationId);
                                return; // Exit early, don't continue polling
                            }
                            
                            // Only show loading state if we're still waiting (no data available yet)
                            // Update UI with current status (dots will be animated)
                            var statusMessage = statusData.processing_by === 'on-demand' 
                                ? 'Scraping showtimes' 
                                : (statusData.processing_by === 'daily-refresh' 
                                    ? 'Daily refresh in progress' 
                                    : 'Processing');
                            showLoadingState(statusMessage);
                            
                            if (statusData.status === 'stale' || statusData.status === 'error') {
                                // Scraping failed, stop polling
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                hideLoadingOverlay();
                                
                                // Always show error state for 'error' status, never show "no showtimes"
                                if (statusData.status === 'error') {
                                    var errorMsg2 = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                    showErrorState(errorMsg2, function() {
                                        var city2 = cityInput.value.trim();
                                        var country2 = countrySelect.value;
                                        var state2 = (cityInput.dataset && cityInput.dataset.state) || '';
                                        if (city2 && country2) {
                                            fetchShowtimes(city2, country2, state2);
                                        }
                                    });
                                } else {
                                    // Only show "no showtimes" for 'stale' status (not error)
                                    var errorMsg3 = statusData.message || '{{ translations.no_showtimes or "No showtimes found" }}';
                                    showEmptyState(errorMsg3, 'üé¨');
                                }
                            }
                            // Otherwise keep polling (status is 'processing')
                        });
                    });
                }).catch(function(e) {
                    console.error('Polling error:', e);
                    // After too many errors, stop polling and show error
                    if (pollCount > 30) { // 30 polls = 60 seconds
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay();
                        showErrorState('Request timed out. Please try again.', function() {
                            var city3 = cityInput.value.trim();
                            var country3 = countrySelect.value;
                            var state3 = (cityInput.dataset && cityInput.dataset.state) || '';
                            if (city3 && country3) {
                                fetchShowtimes(city3, country3, state3);
                            }
                        });
                    }
                    // Otherwise continue polling on error (network issues, etc.)
                });
            }, 2000); // Poll every 2 seconds
        }
        
        function loadShowtimes(locationId) {
            var params = 'city_name=' + encodeURIComponent(locationId);
            if (formatFilter.value) params += '&format=' + encodeURIComponent(formatFilter.value);
            if (languageFilter.value) params += '&language=' + encodeURIComponent(languageFilter.value);
            
            // First check status to see if there's an error
            fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusResponse) {
                return statusResponse.json().then(function(statusData) {
                    // If status is error, show error message instead of loading showtimes
                    if (statusData.status === 'error') {
                        hideLoadingOverlay();
                        var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                        showErrorState(errorMsg, function() {
                            var city = cityInput.value.trim();
                            var country = countrySelect.value;
                            var state = (cityInput.dataset && cityInput.dataset.state) || '';
                            if (city && country) {
                                fetchShowtimes(city, country, state);
                            }
                        });
                        return;
                    }
                    
                    // Load showtimes
                    return fetch('/api/showtimes?' + params).then(function(response) {
                        return response.json().then(function(showtimesData) {
                            showtimes = showtimesData;
                            // Stop animation and render results
                            hideLoadingOverlay();
                            renderShowtimes();
                        });
                    });
                });
            }).catch(function(e) {
                console.error('Error loading showtimes:', e);
                // Stop animation on error
                hideLoadingOverlay();
                showErrorState('Error loading showtimes. Please try again.', function() {
                    loadShowtimes(locationId);
                });
            });
        }
        
        function applyFilters(data) {
            let filtered = [...data];
            
            // Filter out past showtimes first (before other filters)
            const now = new Date();
            filtered = filtered.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (formatFilter.value) {
                filtered = filtered.filter(s => s.format && s.format === formatFilter.value);
            }
            if (languageFilter.value) {
                filtered = filtered.filter(s => 
                    (s.language || '').toLowerCase().includes(languageFilter.value.toLowerCase())
                );
            }
            
            // Sort by start_time (ascending - earliest first)
            filtered.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            return filtered;
        }
        
        // Helper functions for UI states
        function showLoadingSkeleton() {
            // Clear any existing skeleton timeout
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Show spinner first, then skeleton after a brief moment
            showLoadingState('Preparing to load showtimes...');
            skeletonTimeout = setTimeout(() => {
                // Only show skeleton if we're still loading (no error/result shown yet)
                if (container.querySelector('.loading-skeleton') === null && 
                    container.querySelector('.error-state') === null &&
                    container.querySelector('.empty-state') === null) {
                    container.innerHTML = `
                        <div class="loading-skeleton">
                            ${Array(6).fill(0).map(() => `
                                <div class="skeleton-card">
                                    <div class="skeleton-image"></div>
                                    <div class="skeleton-content">
                                        <div class="skeleton-line short"></div>
                                        <div class="skeleton-line medium"></div>
                                        <div class="skeleton-line"></div>
                                        <div class="skeleton-line short"></div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                skeletonTimeout = null;
            }, 500);
        }
        
        function clearLoadingSkeleton() {
            // Clear skeleton timeout if it exists
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Remove skeleton from DOM if present
            const skeleton = container.querySelector('.loading-skeleton');
            if (skeleton) {
                skeleton.remove();
            }
        }
        
        function showLoadingState(message = 'Loading...') {
            // Create or update full-page loading overlay
            let overlay = document.getElementById('loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'loading-overlay';
                overlay.className = 'loading-overlay';
                document.body.appendChild(overlay);
            }
            
            overlay.innerHTML = `
                <div class="loading-overlay-content">
                    <div class="spinner-glow">
                        <span style="font-size: 24px; color: var(--accent); text-shadow: 0 0 10px rgba(52, 152, 219, 0.8);">üé¨</span>
                    </div>
                    <p class="loading-text">${message}<span class="loading-dots"></span></p>
                    <p>Please wait while we fetch the latest showtimes...</p>
                </div>
            `;
            
            // Show overlay with animation
            setTimeout(() => {
                overlay.classList.add('show');
            }, 10);
        }
        
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Remove overlay after animation
                setTimeout(() => {
                    if (overlay && !overlay.classList.contains('show')) {
                        overlay.remove();
                    }
                }, 300);
            }
        }
        
        function showEmptyState(message, icon = 'üé¨') {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing empty state
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">${icon}</div>
                    <h3>${message}</h3>
                    <p>Try searching for a different city or check back later</p>
                </div>
            `;
        }
        
        function showErrorState(message, retryCallback = null) {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing error state
            const errorHtml = `
                <div class="error-state">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <h3>Something went wrong</h3>
                    <p>${message}</p>
                    ${retryCallback ? '<button class="retry-btn" id="retry-btn">Retry</button>' : ''}
                </div>
            `;
            container.innerHTML = errorHtml;
            
            if (retryCallback) {
                const retryBtn = document.getElementById('retry-btn');
                if (retryBtn) {
                    retryBtn.addEventListener('click', retryCallback);
                }
            }
        }
        
        async function renderShowtimes() {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when rendering showtimes
            if (!showtimes || showtimes.length === 0) {
                // Before showing "No showtimes", check if there's an error status
                try {
                    const city = cityInput.value.trim();
                    const country = countrySelect.value;
                    const state = stateInput.value.trim() || cityInput.dataset.state || '';
                    if (city && country) {
                        const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                        const statusResponse = await fetch(`/api/scrape/status/${encodeURIComponent(locationId)}`);
                        const statusData = await statusResponse.json();
                        
                        // If status is error, show error message instead of "no showtimes"
                        if (statusData.status === 'error') {
                            const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                            showErrorState(errorMsg, () => {
                                if (city && country) {
                                    fetchShowtimes(city, country, state);
                                }
                            });
                            return;
                        }
                    }
                } catch (e) {
                    // If status check fails, continue to show empty state
                    console.log('Could not check status:', e);
                }
                showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                return;
            }
            
            // Filter out past showtimes on frontend (additional safety check)
            const now = new Date();
            const futureShowtimes = showtimes.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (futureShowtimes.length === 0) {
                // Before showing "No upcoming showtimes", check if there's an error status
                try {
                    const city = cityInput.value.trim();
                    const country = countrySelect.value;
                    const state = stateInput.value.trim() || cityInput.dataset.state || '';
                    if (city && country) {
                        const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                        const statusResponse = await fetch(`/api/scrape/status/${encodeURIComponent(locationId)}`);
                        const statusData = await statusResponse.json();
                        
                        // If status is error, show error message instead of "no showtimes"
                        if (statusData.status === 'error') {
                            const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                            showErrorState(errorMsg, () => {
                                if (city && country) {
                                    fetchShowtimes(city, country, state);
                                }
                            });
                            return;
                        }
                    }
                } catch (e) {
                    // If status check fails, continue to show empty state
                    console.log('Could not check status:', e);
                }
                showEmptyState('{{ translations.no_showtimes or "No upcoming showtimes found" }}', 'üé¨');
                return;
            }
            
            // Sort showtimes by start_time (ascending - earliest first)
            // This ensures showtimes are displayed in chronological order
            futureShowtimes.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            container.innerHTML = '<div class="showtimes-grid"></div>';
            var grid = container.querySelector('.showtimes-grid');
            
            for (var stIdx = 0; stIdx < futureShowtimes.length; stIdx++) {
                var st = futureShowtimes[stIdx];
                var card = document.createElement('div');
                card.className = 'showtime-card';
                
                // Get movie title in selected language
                var currentLang = '{{ lang }}';
                var movieTitle = 'Unknown Movie';
                if (st.movie && st.movie[currentLang]) {
                    movieTitle = st.movie[currentLang];
                } else if (st.movie && st.movie.en) {
                    movieTitle = st.movie.en;
                } else if (st.movie && st.movie.local) {
                    movieTitle = st.movie.local;
                } else if (st.movie && st.movie.ua) {
                    movieTitle = st.movie.ua;
                } else if (st.movie && st.movie.ru) {
                    movieTitle = st.movie.ru;
                }
                
                // Get movie description in selected language
                var movieDescription = '';
                if (st.movie_description && st.movie_description[currentLang]) {
                    movieDescription = st.movie_description[currentLang];
                } else if (st.movie_description && st.movie_description.en) {
                    movieDescription = st.movie_description.en;
                } else if (st.movie_description && st.movie_description.ua) {
                    movieDescription = st.movie_description.ua;
                } else if (st.movie_description && st.movie_description.ru) {
                    movieDescription = st.movie_description.ru;
                }
                
                // Simplified date formatting - preserve timezone from ISO string
                var startTime;
                try {
                    var date = new Date(st.start_time);
                    if (isNaN(date.getTime())) {
                        startTime = 'Invalid date';
                    } else {
                        // Extract timezone from ISO string if present
                        var tzMatch = st.start_time.match(/([+-]\d{2}):(\d{2})$/);
                        var tzOffset = tzMatch ? tzMatch[0] : null;
                        
                        // Format date in locale-aware way
                        var options = {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        };
                        
                        startTime = date.toLocaleString('{{ lang }}', options);
                        
                        // Add timezone if not UTC
                        if (tzOffset && tzOffset !== '+00:00' && tzOffset !== 'Z') {
                            startTime += ' (UTC' + tzOffset + ')';
                        }
                    }
                } catch (e) {
                    startTime = st.start_time || 'Invalid date';
                }
                var cinemaName = st.cinema_name || st.cinema_id || 'Unknown Cinema';
                // Get translated cinema address (falls back to original if translation not available)
                var cinemaAddress = st.cinema_address_translated || st.cinema_address || '';
                var hallInfo = st.hall ? ' | ' + st.hall : '';
                
                // Movie image with error handling
                var imagePath = st.movie_image_path || '';
                var imageHtml = imagePath 
                    ? '<img src="' + imagePath + '" alt="' + movieTitle + '" class="movie-image" loading="lazy" onerror="this.style.display=\'none\'; this.nextElementSibling.style.display=\'flex\';">'
                    : '';
                var placeholderHtml = '<div class="movie-image-placeholder" style="' + (imagePath ? 'display:none;' : '') + '">üé¨</div>';
                
                // Cinema address display
                var cinemaAddressHtml = cinemaAddress
                    ? '<div class="cinema-address">üìç ' + cinemaAddress + '</div>'
                    : '';
                
                // Build format/language/hall info
                var formatParts = [];
                if (st.format) formatParts.push(st.format);
                if (st.language) formatParts.push(st.language);
                if (hallInfo) formatParts.push(hallInfo);
                var formatInfo = formatParts.join(' | ');
                
                // Build movie description HTML
                var movieDescHtml = movieDescription 
                    ? '<div class="movie-description" style="font-size: 0.9rem; opacity: 0.85; margin: 0.5rem 0; line-height: 1.4; max-height: 3.6em; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;">' + movieDescription + '</div>'
                    : '';
                
                // Build buy button HTML
                var buyBtnHtml = st.cinema_website 
                    ? '<a href="' + st.cinema_website + '" target="_blank" class="buy-btn" aria-label="Buy tickets for ' + movieTitle + '">{{ translations.buy_tickets }}</a>'
                    : '';
                
                card.innerHTML = 
                    '<div class="movie-image-container">' +
                        imageHtml +
                        placeholderHtml +
                    '</div>' +
                    '<div class="showtime-card-content">' +
                        '<h3>' + movieTitle + '</h3>' +
                        movieDescHtml +
                        '<div class="time">' + startTime + '</div>' +
                        '<div class="cinema">' +
                            '<div class="cinema-name">' + cinemaName + '</div>' +
                            cinemaAddressHtml +
                        '</div>' +
                        '<div style="margin-top: auto; padding-top: 1rem;">' +
                            '<div style="margin-bottom: 0.5rem; opacity: 0.8;">' + formatInfo + '</div>' +
                            buyBtnHtml +
                        '</div>' +
                    '</div>';
                
                grid.appendChild(card);
            }
        }
        
        // Filter event listeners
        var filters = [formatFilter, languageFilter];
        for (var fIdx = 0; fIdx < filters.length; fIdx++) {
            var filter = filters[fIdx];
            filter.addEventListener('change', function() {
                if (currentCity) {
                    var locationId = currentCountry ? currentCity + ', ' + currentCountry : currentCity;
                    loadShowtimes(locationId);
                }
            });
        }
        
        // Cleanup polling on page unload
        window.addEventListener('beforeunload', function() {
            if (pollingInterval) clearInterval(pollingInterval);
        });
        
        // Feedback Modal
        var feedbackBtn = document.getElementById('feedback-btn');
        var feedbackModal = document.getElementById('feedback-modal');
        var feedbackClose = document.getElementById('feedback-close');
        var feedbackCancel = document.getElementById('feedback-cancel');
        var feedbackForm = document.getElementById('feedback-form');
        var feedbackMessageDisplay = document.getElementById('feedback-message-display');
        
        function openFeedbackModal() {
            feedbackModal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }
        
        function closeFeedbackModal() {
            feedbackModal.style.display = 'none';
            document.body.style.overflow = 'auto';
            feedbackForm.reset();
            feedbackMessageDisplay.style.display = 'none';
        }
        
        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackClose.addEventListener('click', closeFeedbackModal);
        feedbackCancel.addEventListener('click', closeFeedbackModal);
        
        // Close modal when clicking outside
        feedbackModal.addEventListener('click', function(e) {
            if (e.target === feedbackModal) {
                closeFeedbackModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && feedbackModal.style.display === 'block') {
                closeFeedbackModal();
            }
        });
        
        // Handle feedback form submission
        feedbackForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            var submitBtn = feedbackForm.querySelector('.btn-submit');
            var originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            
            var formData = {
                name: document.getElementById('feedback-name').value.trim(),
                email: document.getElementById('feedback-email').value.trim(),
                message: document.getElementById('feedback-message').value.trim()
            };
            
            fetch('/api/feedback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(formData)
            }).then(function(response) {
                return response.json().then(function(data) {
                    feedbackMessageDisplay.style.display = 'block';
                    
                    if (data.success) {
                        feedbackMessageDisplay.className = 'success';
                        feedbackMessageDisplay.textContent = '{{ translations.feedback_sent }}';
                        feedbackForm.reset();
                        
                        // Close modal after 2 seconds
                        setTimeout(function() {
                            closeFeedbackModal();
                        }, 2000);
                    } else {
                        feedbackMessageDisplay.className = 'error';
                        feedbackMessageDisplay.textContent = data.error || '{{ translations.feedback_error }}';
                    }
                    
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                });
            }).catch(function(error) {
                console.error('Feedback error:', error);
                feedbackMessageDisplay.style.display = 'block';
                feedbackMessageDisplay.className = 'error';
                feedbackMessageDisplay.textContent = '{{ translations.feedback_error }}';
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            });
        });
    </script>
    
    <!-- Ko-fi Widget -->
    <!-- 
      If widget appears empty, check browser console for errors.
      Common issues:
      1. Content Security Policy (CSP) blocking - Add to nginx/security headers:
         script-src 'self' 'unsafe-inline' https://storage.ko-fi.com https://*.ko-fi.com;
         frame-src 'self' https://*.ko-fi.com;
         img-src 'self' data: https://*.ko-fi.com;
      2. Ad blockers - Test in incognito mode
      3. Script loading - Check Network tab for 404 errors
    -->
    <script>
      // Initialize Ko-fi widget after script loads
      function initKofiWidget() {
        if (typeof kofiWidgetOverlay !== 'undefined') {
          try {
            kofiWidgetOverlay.draw('oleksandrdon', {
              'type': 'floating-chat',
              'floating-chat.donateButton.text': 'Support Us',
              'floating-chat.donateButton.background-color': '#fcbf47',
              'floating-chat.donateButton.text-color': '#323842'
            });
            console.log('‚úì Ko-fi widget initialized successfully');
          } catch (error) {
            console.error('‚úó Ko-fi widget error:', error);
            console.error('Error details:', error.message, error.stack);
          }
        } else {
          console.error('‚úó kofiWidgetOverlay is not defined. Script may not have loaded correctly.');
        }
      }
      
      // Load Ko-fi script and initialize when ready
      (function() {
        var script = document.createElement('script');
        script.src = 'https://storage.ko-fi.com/cdn/scripts/overlay-widget.js';
        script.async = true;
        script.onload = function() {
          // Wait a tiny bit for the script to fully initialize
          setTimeout(initKofiWidget, 100);
        };
        script.onerror = function() {
          console.error('‚úó Failed to load Ko-fi widget script. Check Network tab for errors.');
        };
        document.head.appendChild(script);
      })();
    </script>
</body>
</html>



<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#1a1f3a">
    <meta name="mobile-web-app-capable" content="yes">
    <title>{{ translations.title }}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --midnight-blue: #1a1f3a;
            --charcoal: #2c3e50;
            --slate: #34495e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --text-light: #ecf0f1;
            --text-dark: #2c3e50;
            --success: #27ae60;
            --warning: #f39c12;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--midnight-blue) 0%, var(--charcoal) 100%);
            color: var(--text-light);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* Header */
        header {
            background: rgba(26, 31, 58, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }
        
        .nav-links {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .donate-btn {
            background: var(--success);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .donate-btn:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }
        
        .donate-btn .flag-emoji {
            display: inline-block;
        }
        
        .donate-btn .flag-fallback {
            display: none;
            background: linear-gradient(to bottom, #0057B7 0%, #0057B7 50%, #FFD700 50%, #FFD700 100%);
            color: transparent;
            background-clip: text;
            -webkit-background-clip: text;
            font-weight: bold;
            font-size: 0.9em;
            padding: 0 0.2em;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            background-color: rgba(0, 87, 183, 0.8);
            color: #FFD700;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }
        
        /* Fallback for old Android: show text flag if emoji doesn't render */
        .donate-btn.flag-not-supported .flag-emoji {
            display: none;
        }
        
        .donate-btn.flag-not-supported .flag-fallback {
            display: inline-block;
        }
        
        .lang-selector {
            display: flex;
            gap: 0.5rem;
        }
        
        .lang-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .lang-btn:hover, .lang-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        /* Main Content */
        main {
            padding: 2rem 0;
        }
        
        .hero {
            text-align: center;
            padding: 3rem 0;
        }
        
        .hero h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--accent), #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .filters {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 10px;
            margin: 2rem 0;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .location-search-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 1rem;
        }
        
        .additional-filters-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .filter-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--accent);
            display: flex;
            align-items: flex-start; /* Align to top to prevent misalignment */
            gap: 0.5rem;
            flex-wrap: wrap;
            min-height: 2.5rem; /* Reserve space for 2 lines of text to keep inputs aligned */
            line-height: 1.25;
        }
        
        /* Ensure all filter groups in the location search row have consistent alignment */
        .location-search-row .filter-group {
            justify-content: flex-start;
        }
        
        /* Keep inputs aligned at the same vertical position */
        .location-search-row .filter-group input,
        .location-search-row .filter-group select,
        .location-search-row .filter-group .country-input-group {
            margin-top: 0; /* Remove any top margin to keep alignment consistent */
        }
        
        .auto-detected-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid var(--accent);
            border-radius: 12px;
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            user-select: none;
        }
        
        .auto-detected-badge:hover {
            background: rgba(52, 152, 219, 0.3);
            transform: scale(1.05);
        }
        
        .filter-group select,
        .filter-group input {
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .showtimes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .showtime-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 0;
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: var(--accent);
        }
        
        .movie-image-container {
            width: 100%;
            height: 300px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .movie-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        
        .showtime-card:hover .movie-image {
            transform: scale(1.05);
        }
        
        .movie-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--charcoal), var(--slate));
            color: var(--text-light);
            font-size: 3rem;
            opacity: 0.5;
        }
        
        .showtime-card-content {
            padding: 1.5rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .showtime-card h3 {
            color: var(--accent);
            margin-bottom: 0.5rem;
            font-size: 1.3rem;
        }
        
        .showtime-card .time {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0.5rem 0;
            color: var(--text-light);
        }
        
        .showtime-card .cinema {
            color: var(--text-light);
            margin-bottom: 0.5rem;
        }
        
        .showtime-card .cinema-name {
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }
        
        .showtime-card .cinema-address {
            font-size: 0.9rem;
            opacity: 0.9;
            color: var(--text-light);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .buy-btn {
            display: inline-block;
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: white;
            text-align: center;
            text-decoration: none;
            border-radius: 5px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }
        
        .buy-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.02);
        }
        
        .city-input-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .city-input-group input {
            flex: 1;
        }
        
        .search-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .search-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        .location-input-group {
            position: relative;
            overflow: visible; /* Ensure dropdowns are not clipped */
        }
        
        .country-input-group {
            overflow: visible; /* Ensure dropdowns are not clipped */
        }
        
        .location-input-group input {
            width: 100%;
            padding-right: 3rem; /* Make room for location button */
        }
        
        #manual-location-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s ease;
            color: var(--accent);
            line-height: 1;
        }
        
        #manual-location-btn:hover {
            background: rgba(52, 152, 219, 0.4);
            transform: translateY(-50%) scale(1.1);
        }
        
        #manual-location-btn:active {
            transform: translateY(-50%) scale(0.95);
        }
        
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            width: 100%;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            visibility: hidden;
            opacity: 0;
        }
        
        .suggestions-dropdown.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: absolute !important;
            z-index: 9999 !important;
        }
        
        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .suggestion-item:hover,
        .suggestion-item.selected {
            background: var(--accent);
        }
        
        .suggestion-item.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item small {
            opacity: 0.7;
        }
        
        /* Footer */
        footer {
            background: rgba(26, 31, 58, 0.95);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
        }
        
        .visitor-counter {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            font-size: 1.5rem;
        }
        
        /* Full-page loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loading-overlay.show {
            opacity: 1;
        }
        
        .loading-overlay-content {
            text-align: center;
            color: white;
        }
        
        .loading-overlay .spinner-glow {
            margin: 0 auto 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Center the movie icon inside spinner */
        .loading-overlay .spinner-glow > * {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            width: auto;
            height: auto;
            margin: 0;
        }
        
        .loading-overlay .loading-text {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .loading-overlay p {
            font-size: 1rem;
            opacity: 0.8;
            margin-top: 0.5rem;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }
        
        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }
        
        /* Loading Skeleton */
        .loading-skeleton {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .skeleton-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            animation: skeleton-pulse 1.5s ease-in-out infinite;
        }
        
        .skeleton-image {
            width: 100%;
            height: 300px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .skeleton-content {
            padding: 1.5rem;
        }
        
        .skeleton-line {
            height: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-bottom: 0.75rem;
        }
        
        .skeleton-line.short {
            width: 60%;
        }
        
        .skeleton-line.medium {
            width: 80%;
        }
        
        @keyframes skeleton-pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        
        /* Spinner - Enhanced Cool Animation */
        .spinner {
            display: inline-block;
            width: 60px;
            height: 60px;
            position: relative;
            margin: 0 auto 1.5rem;
        }
        
        .spinner::before,
        .spinner::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
        }
        
        .spinner::before {
            width: 60px;
            height: 60px;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.3);
        }
        
        .spinner::after {
            width: 40px;
            height: 40px;
            top: 10px;
            left: 10px;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.3);
            animation: spin 0.8s linear infinite reverse;
        }
        
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        /* Enhanced Cool Spinner with Glow Effect */
        .spinner-glow {
            display: inline-block;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(52, 152, 219, 0.4) 0%, rgba(155, 89, 182, 0.2) 50%, transparent 70%);
            animation: pulse 2s ease-in-out infinite;
            margin: 0 auto 2rem;
            position: relative;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
        }
        
        .spinner-glow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            border: 5px solid transparent;
            border-top-color: var(--accent);
            border-right-color: rgba(52, 152, 219, 0.4);
            border-bottom-color: rgba(52, 152, 219, 0.2);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6);
            margin: 0;
            z-index: 1;
            transform-origin: center center;
        }
        
        .spinner-glow::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 45px;
            height: 45px;
            border: 4px solid transparent;
            border-top-color: #9b59b6;
            border-right-color: rgba(155, 89, 182, 0.5);
            border-bottom-color: rgba(155, 89, 182, 0.2);
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);
            margin: 0;
            z-index: 2;
            transform-origin: center center;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
                box-shadow: 0 0 30px rgba(52, 152, 219, 0.5), 0 0 60px rgba(155, 89, 182, 0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.15);
                box-shadow: 0 0 40px rgba(52, 152, 219, 0.7), 0 0 80px rgba(155, 89, 182, 0.5);
            }
        }
        
        /* Movie icon animation in spinner center */
        @keyframes iconFloat {
            0%, 100% {
                transform: translate(-50%, -50%) translateY(0) rotate(0deg);
            }
            50% {
                transform: translate(-50%, -50%) translateY(-5px) rotate(5deg);
            }
        }
        
        .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
            z-index: 10;
        }
        
        /* Ensure iconFloat animation preserves centering for loading overlay */
        .loading-overlay .spinner-glow > * {
            animation: iconFloat 3s ease-in-out infinite;
        }
        
        /* Loading text animation */
        .loading-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent);
            margin-top: 1.5rem;
            animation: fadeInOut 2s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            letter-spacing: 0.5px;
        }
        
        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0.7;
                transform: translateY(0);
            }
            50% {
                opacity: 1;
                transform: translateY(-3px);
            }
        }
        
        .loading-dots {
            display: inline-block;
            width: 1ch;
        }
        
        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% {
                content: '.';
            }
            40% {
                content: '..';
            }
            60%, 100% {
                content: '...';
            }
        }
        
        
        /* Error State */
        .error-state {
            text-align: center;
            padding: 3rem;
        }
        
        .error-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: var(--warning);
        }
        
        .error-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--warning);
        }
        
        .error-state p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .retry-btn {
            padding: 0.75rem 2rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .retry-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }
        
        /* Country Search Input */
        .country-input-group {
            position: relative;
        }
        
        .country-input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .country-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            width: 100%;
            background: var(--charcoal);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
            visibility: hidden;
            opacity: 0;
        }
        
        .country-dropdown.show {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: absolute !important;
            z-index: 9999 !important;
        }
        
        .country-option {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .country-option:hover,
        .country-option.selected {
            background: var(--accent);
        }
        
        .country-option.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }
        
        .country-option:last-child {
            border-bottom: none;
        }
        
        /* Focus States for Accessibility */
        *:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .filter-group input:focus,
        .filter-group select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .buy-btn:focus-visible,
        .search-btn:focus-visible,
        .donate-btn:focus-visible,
        .lang-btn:focus-visible,
        .retry-btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        /* Image Error Handling */
        .movie-image {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .movie-image[src=""],
        .movie-image:not([src]) {
            display: none;
        }
        
        /* Desktop Optimizations (Large Screens) */
        @media (min-width: 1200px) {
            .container {
                max-width: 1400px;
                padding: 0 40px;
            }
            
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: 2rem;
            }
            
            .filters {
                padding: 2rem;
            }
            
            .location-search-row {
                grid-template-columns: 2fr 1fr 1fr 1fr;
            }
            
            .hero h1 {
                font-size: 3.5rem;
            }
            
            .showtime-card-content {
                padding: 2rem;
            }
        }
        
        /* Desktop (Standard) */
        @media (min-width: 1024px) and (max-width: 1199px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
            
            .location-search-row {
                grid-template-columns: 2fr 1fr 1fr 1fr;
            }
        }
        
        /* Tablet and Medium Screens */
        @media (min-width: 769px) and (max-width: 1023px) {
            .showtimes-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
            
            .location-search-row {
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
            
            .location-search-row .city-group {
                grid-column: span 2;
            }
            
            .location-search-row .search-group {
                grid-column: span 2;
            }
        }
        
        /* Mobile and Small Tablets */
        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }
            
            header {
                padding: 0.75rem 0;
            }
            
            .logo {
                font-size: 1.25rem;
            }
            
            nav {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            
            .nav-links {
                gap: 0.5rem;
            }
            
            .lang-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.9rem;
            }
            
            .donate-btn {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }
            
            main {
                padding: 1.5rem 0;
            }
            
            .hero {
                padding: 2rem 0;
            }
            
            .hero h1 {
                font-size: 2rem;
                margin-bottom: 0.75rem;
            }
            
            .hero p {
                font-size: 1rem;
            }
            
            .location-search-row {
                grid-template-columns: 1fr;
            }
            
            .additional-filters-row {
                grid-template-columns: 1fr;
            }
            
            .filters {
                padding: 1.25rem;
                gap: 1.25rem;
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 1 !important;
            }
            
            .filter-group label {
                font-size: 0.95rem;
                margin-bottom: 0.4rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.875rem;
                font-size: 1rem;
                min-height: 44px; /* Touch-friendly minimum */
            }
            
            .search-btn {
                padding: 0.875rem 1.5rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .showtimes-grid {
                grid-template-columns: 1fr;
                gap: 1.25rem;
                margin-top: 1.5rem;
            }
            
            .showtime-card {
                border-radius: 12px;
            }
            
            .showtime-card:hover {
                transform: none; /* Disable hover transform on mobile */
            }
            
            .movie-image-container {
                height: 250px;
            }
            
            .showtime-card-content {
                padding: 1.25rem;
            }
            
            .showtime-card h3 {
                font-size: 1.15rem;
            }
            
            .showtime-card .time {
                font-size: 1.1rem;
            }
            
            .buy-btn {
                padding: 0.875rem;
                min-height: 44px; /* Touch-friendly */
                font-size: 1rem;
            }
            
            .loading-skeleton {
                grid-template-columns: 1fr;
                gap: 1.25rem;
            }
            
            .skeleton-image {
                height: 250px;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1.5rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 3rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.25rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 1rem;
            }
            
            .retry-btn {
                padding: 0.875rem 1.75rem;
                min-height: 44px;
                font-size: 1rem;
            }
            
            footer {
                padding: 1.5rem 0;
            }
            
            .visitor-counter {
                font-size: 1.1rem;
            }
        }
        
        /* Small Mobile Devices */
        @media (max-width: 480px) {
            .container {
                padding: 0 12px;
            }
            
            header {
                padding: 0.6rem 0;
            }
            
            .logo {
                font-size: 1.1rem;
            }
            
            .lang-selector {
                gap: 0.4rem;
            }
            
            .lang-btn {
                padding: 0.35rem 0.7rem;
                font-size: 0.85rem;
            }
            
            .donate-btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
            
            main {
                padding: 1rem 0;
            }
            
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
                margin-bottom: 0.5rem;
            }
            
            .hero p {
                font-size: 0.95rem;
            }
            
            .filters {
                padding: 1rem;
                gap: 1rem;
                border-radius: 8px;
            }
            
            .filter-group label {
                font-size: 0.9rem;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .search-btn {
                padding: 0.75rem 1.25rem;
                font-size: 0.95rem;
            }
            
            .showtimes-grid {
                gap: 1rem;
                margin-top: 1.25rem;
            }
            
            .movie-image-container {
                height: 220px;
            }
            
            .showtime-card-content {
                padding: 1rem;
            }
            
            .showtime-card h3 {
                font-size: 1.1rem;
            }
            
            .showtime-card .time {
                font-size: 1rem;
            }
            
            .showtime-card .cinema-address {
                font-size: 0.85rem;
            }
            
            .buy-btn {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .loading-skeleton {
                gap: 1rem;
            }
            
            .skeleton-image {
                height: 220px;
            }
            
            .skeleton-content {
                padding: 1rem;
            }
            
            .empty-state,
            .error-state {
                padding: 2rem 1rem;
            }
            
            .empty-state-icon,
            .error-icon {
                font-size: 2.5rem;
            }
            
            .empty-state h3,
            .error-state h3 {
                font-size: 1.1rem;
            }
            
            .empty-state p,
            .error-state p {
                font-size: 0.95rem;
            }
            
            .spinner {
                width: 35px;
                height: 35px;
            }
            
            footer {
                padding: 1.25rem 0;
            }
            
            .visitor-counter {
                font-size: 1rem;
            }
        }
        
        /* Very Small Mobile Devices */
        @media (max-width: 360px) {
            .hero h1 {
                font-size: 1.5rem;
            }
            
            .filters {
                padding: 0.875rem;
            }
            
            .movie-image-container {
                height: 200px;
            }
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--charcoal);
            margin: 5% auto;
            padding: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-header h2 {
            margin: 0;
            color: var(--accent);
            font-size: 1.5rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--warning);
        }
        
        .modal form {
            padding: 1.5rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent);
            font-weight: 600;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 5px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-color: var(--accent);
        }
        
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }
        
        .btn-cancel,
        .btn-submit {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }
        
        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-submit {
            background: var(--accent);
            color: white;
        }
        
        .btn-submit:hover {
            background: var(--accent-hover);
        }
        
        .btn-submit:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #feedback-message-display {
            padding: 1rem;
            border-radius: 5px;
            text-align: center;
        }
        
        #feedback-message-display.success {
            background: rgba(39, 174, 96, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        
        #feedback-message-display.error {
            background: rgba(243, 156, 18, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 10% auto;
            }
            
            .modal-header {
                padding: 1rem;
            }
            
            .modal form {
                padding: 1rem;
            }
            
            .form-actions {
                flex-direction: column;
            }
            
            .btn-cancel,
            .btn-submit {
                width: 100%;
            }
        }
        
        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Disable hover effects on touch devices */
            .showtime-card:hover {
                transform: none;
                box-shadow: none;
            }
            
            .showtime-card:hover .movie-image {
                transform: none;
            }
            
            /* Increase touch targets */
            .lang-btn,
            .donate-btn,
            .search-btn,
            .buy-btn,
            .retry-btn {
                min-height: 44px;
            }
            
            .suggestion-item,
            .country-option {
                min-height: 44px;
                padding: 1rem 0.75rem;
            }
        }
        
        /* Desktop Hover Enhancements */
        @media (hover: hover) and (pointer: fine) {
            .showtime-card {
                cursor: pointer;
            }
            
            .suggestion-item:hover,
            .country-option:hover {
                background: var(--accent);
                transform: translateX(4px);
            }
        }
        
        /* Landscape Mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .hero {
                padding: 1.5rem 0;
            }
            
            .hero h1 {
                font-size: 1.75rem;
            }
            
            .filters {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .filter-group[style*="grid-column: span 2"] {
                grid-column: span 2 !important;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav class="container">
            <a href="{{ base_path }}" style="text-decoration: none; color: inherit;"><div class="logo">CineStream</div></a>
            <div class="nav-links">
                <div class="lang-selector">
                    <a href="/set-language/en" class="lang-btn {{ 'active' if lang == 'en' else '' }}">EN</a>
                    <a href="/set-language/ua" class="lang-btn {{ 'active' if lang == 'ua' else '' }}">UA</a>
                    <a href="/set-language/ru" class="lang-btn {{ 'active' if lang == 'ru' else '' }}">RU</a>
                </div>
                <a href="{{ donation_url }}" target="_blank" class="donate-btn">
                    <span class="flag-emoji">üá∫üá¶</span>
                    <span class="flag-fallback" style="display: none;">UA</span>
                    {{ translations.donate }}
                </a>
            </div>
        </nav>
    </header>
    
    <main class="container">
        <div class="hero">
            <h1>{{ translations.title }}</h1>
            <p>{{ translations.select_city }}</p>
        </div>
        
        <div class="filters">
            <div class="location-search-row">
                <div class="filter-group city-group">
                    <label for="city-input">
                        {{ translations.select_city }}
                        <span class="auto-detected-badge" id="auto-detected-badge" style="display: none;" title="Location auto-detected from your device. Click to clear.">üìç Auto-detected</span>
                    </label>
                <div class="location-input-group">
                    <input type="text" id="city-input" placeholder="Enter city name..." autocomplete="off" aria-label="City name input">
                    <div id="city-suggestions" class="suggestions-dropdown" role="listbox" aria-label="City suggestions"></div>
                </div>
            </div>
            
                <div class="filter-group state-group">
                    <label for="state-input">{{ translations.state_province or 'State/Province (optional)' }}</label>
                    <input type="text" id="state-input" placeholder="{{ translations.state_province or 'State/Province...' }}" autocomplete="off" aria-label="State or Province input">
            </div>
            
                <div class="filter-group country-group">
                <label for="country-input">{{ translations.country or 'Country' }}</label>
                <div class="country-input-group">
                    <input type="text" id="country-input" placeholder="Search or select country..." autocomplete="off" aria-label="Country selector">
                    <div id="country-dropdown" class="country-dropdown"></div>
                </div>
                <select id="country-select" style="display: none;" aria-label="Country selector">
                    <option value="">All Countries</option>
                </select>
            </div>
            
                <div class="filter-group search-group">
                <label>&nbsp;</label>
                <button id="search-btn" class="search-btn" aria-label="Search for movie showtimes">üîç Search Showtimes</button>
                </div>
            </div>
            
            <div class="additional-filters-row">
            <div class="filter-group">
                <label for="format-filter">{{ translations.filter_by_format }}</label>
                <select id="format-filter" aria-label="Filter by movie format">
                    <option value="">All Formats</option>
                    <option value="2D">2D</option>
                    <option value="3D">3D</option>
                    <option value="IMAX">IMAX</option>
                    <option value="4DX">4DX</option>
                    <option value="Dolby Atmos">Dolby Atmos</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="language-filter">{{ translations.filter_by_language }}</label>
                <select id="language-filter" aria-label="Filter by language">
                    <option value="">All Languages</option>
                    <option value="Ukrainian">Ukrainian</option>
                    <option value="English">English</option>
                    <option value="Russian">Russian</option>
                    <option value="Original">Original</option>
                </select>
                </div>
            </div>
        </div>
        
        <div id="showtimes-container">
            <div class="empty-state">
                <div class="empty-state-icon">üé¨</div>
                <h3>{{ translations.select_city or 'Select a City' }}</h3>
                <p>Enter a city name and country above to find movie showtimes</p>
            </div>
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p class="visitor-counter">{{ translations.visitor_count }}: {{ visitor_count }}</p>
            <div style="margin-top: 1rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                <a href="/terms" style="color: var(--accent); text-decoration: none;">{{ translations.terms }}</a>
                <button id="feedback-btn" style="background: none; border: none; color: var(--accent); cursor: pointer; text-decoration: underline; font-size: inherit; font-family: inherit;">{{ translations.feedback }}</button>
            </div>
            <p style="margin-top: 1rem; opacity: 0.7;">¬© 2025 CineStream. All rights reserved.</p>
        </div>
    </footer>
    
    <!-- Feedback Modal -->
    <div id="feedback-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>{{ translations.feedback }}</h2>
                <button class="modal-close" id="feedback-close">&times;</button>
            </div>
            <form id="feedback-form">
                <div class="form-group">
                    <label for="feedback-name">Name (optional)</label>
                    <input type="text" id="feedback-name" name="name" placeholder="Your name">
                </div>
                <div class="form-group">
                    <label for="feedback-email">Email (optional)</label>
                    <input type="email" id="feedback-email" name="email" placeholder="your.email@example.com">
                </div>
                <div class="form-group">
                    <label for="feedback-message">Message <span style="color: var(--warning);">*</span></label>
                    <textarea id="feedback-message" name="message" rows="6" placeholder="Your feedback, suggestions, or questions..." required></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-cancel" id="feedback-cancel">Cancel</button>
                    <button type="submit" class="btn-submit">{{ translations.send_feedback }}</button>
                </div>
                <div id="feedback-message-display" style="margin-top: 1rem; display: none;"></div>
            </form>
        </div>
    </div>
    
    <script>
        // Feature detection for old devices
        var supportsFetch = typeof fetch !== 'undefined';
        var supportsPromise = typeof Promise !== 'undefined';
        var supportsAsyncAwait = (function() {
            try {
                new Function('async () => {}');
                return true;
            } catch (e) {
                return false;
            }
        })();
        var supportsArrayFrom = typeof Array.from !== 'undefined';
        var supportsArrayFind = Array.prototype.find !== undefined;
        var supportsArrayIncludes = Array.prototype.includes !== undefined;
        
        // Promise polyfill for old Android devices (simplified version)
        if (!supportsPromise) {
            window.Promise = function(executor) {
                var self = this;
                self.state = 'pending';
                self.value = undefined;
                self.handlers = [];
                
                function resolve(result) {
                    if (self.state === 'pending') {
                        self.state = 'fulfilled';
                        self.value = result;
                        self.handlers.forEach(handle);
                        self.handlers = null;
                    }
                }
                
                function reject(error) {
                    if (self.state === 'pending') {
                        self.state = 'rejected';
                        self.value = error;
                        self.handlers.forEach(handle);
                        self.handlers = null;
                    }
                }
                
                function handle(handler) {
                    if (self.state === 'pending') {
                        self.handlers.push(handler);
                    } else {
                        if (self.state === 'fulfilled' && typeof handler.onFulfilled === 'function') {
                            handler.onFulfilled(self.value);
                        }
                        if (self.state === 'rejected' && typeof handler.onRejected === 'function') {
                            handler.onRejected(self.value);
                        }
                    }
                }
                
                self.then = function(onFulfilled, onRejected) {
                    return new Promise(function(resolve, reject) {
                        handle({
                            onFulfilled: function(result) {
                                try {
                                    resolve(onFulfilled ? onFulfilled(result) : result);
                                } catch (ex) {
                                    reject(ex);
                                }
                            },
                            onRejected: function(error) {
                                try {
                                    if (onRejected) {
                                        var result = onRejected(error);
                                        resolve(result);
                                    } else {
                                        reject(error);
                                    }
                                } catch (ex) {
                                    reject(ex);
                                }
                            }
                        });
                    });
                };
                
                self.catch = function(onRejected) {
                    return self.then(null, onRejected);
                };
                
                try {
                    executor(resolve, reject);
                } catch (ex) {
                    reject(ex);
                }
            };
            
            Promise.resolve = function(value) {
                return new Promise(function(resolve) {
                    resolve(value);
                });
            };
            
            Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason);
                });
            };
        }
        
        // Polyfill for Array.from (for IE11 and older)
        if (!supportsArrayFrom) {
            Array.from = function(arrayLike) {
                var result = [];
                for (var i = 0; i < arrayLike.length; i++) {
                    result.push(arrayLike[i]);
                }
                return result;
            };
        }
        
        // Polyfill for classList.add/remove if not fully supported (old Android)
        // Use try-catch to safely check for classList support
        var classListSupported = false;
        try {
            if (typeof Element !== 'undefined' && Element.prototype) {
                var testDiv = document.createElement('div');
                if (testDiv.classList && typeof testDiv.classList.add === 'function') {
                    classListSupported = true;
                }
            }
        } catch (e) {
            // classList not supported, will use polyfill
            classListSupported = false;
        }
        
        if (!classListSupported) {
            // Basic classList polyfill
            if (typeof Element !== 'undefined' && Element.prototype) {
                Element.prototype.classList = {
                    add: function(className) {
                        if (!this || typeof this.className === 'undefined') return;
                        var currentClasses = this.className || '';
                        if (currentClasses.indexOf(className) === -1) {
                            this.className = currentClasses + (currentClasses ? ' ' : '') + className;
                        }
                    },
                    remove: function(className) {
                        if (!this || typeof this.className === 'undefined') return;
                        this.className = (this.className || '').replace(new RegExp('(^|\\s)' + className + '(\\s|$)', 'g'), ' ').trim();
                    },
                    contains: function(className) {
                        if (!this || typeof this.className === 'undefined') return false;
                        return (this.className || '').indexOf(className) !== -1;
                    },
                    toggle: function(className) {
                        if (!this || typeof this.className === 'undefined') return;
                        if (this.classList.contains(className)) {
                            this.classList.remove(className);
                        } else {
                            this.classList.add(className);
                        }
                    }
                };
            }
        }
        
        // Helper function to safely add/remove classes (works on all browsers)
        function addClass(element, className) {
            if (!element) return;
            // Check if element is actually an Element/DOM node
            if (typeof element.nodeType === 'undefined') return;
            try {
                if (element.classList && typeof element.classList.add === 'function') {
                    element.classList.add(className);
                } else {
                    // Fallback for browsers without classList
                    var currentClasses = element.className || '';
                    if (currentClasses.indexOf(className) === -1) {
                        element.className = currentClasses + (currentClasses ? ' ' : '') + className;
                    }
                }
            } catch (e) {
                // If classList fails, use className fallback
                var currentClasses = element.className || '';
                if (currentClasses.indexOf(className) === -1) {
                    element.className = currentClasses + (currentClasses ? ' ' : '') + className;
                }
            }
        }
        
        function removeClass(element, className) {
            if (!element) return;
            // Check if element is actually an Element/DOM node
            if (typeof element.nodeType === 'undefined') return;
            try {
                if (element.classList && typeof element.classList.remove === 'function') {
                    element.classList.remove(className);
                } else {
                    // Fallback for browsers without classList
                    var currentClasses = element.className || '';
                    element.className = currentClasses.replace(new RegExp('(^|\\s)' + className + '(\\s|$)', 'g'), ' ').trim();
                }
            } catch (e) {
                // If classList fails, use className fallback
                var currentClasses = element.className || '';
                element.className = currentClasses.replace(new RegExp('(^|\\s)' + className + '(\\s|$)', 'g'), ' ').trim();
            }
        }
        
        function hasClass(element, className) {
            if (!element) return false;
            // Check if element is actually an Element/DOM node
            if (typeof element.nodeType === 'undefined') return false;
            try {
                if (element.classList && typeof element.classList.contains === 'function') {
                    return element.classList.contains(className);
                } else {
                    var currentClasses = element.className || '';
                    return currentClasses.indexOf(className) !== -1;
                }
            } catch (e) {
                // If classList fails, use className fallback
                var currentClasses = element.className || '';
                return currentClasses.indexOf(className) !== -1;
            }
        }
        
        // Helper function to show dropdown (for old Android compatibility)
        function showDropdown(element) {
            if (!element) return;
            addClass(element, 'show');
            element.style.display = 'block';
            element.style.visibility = 'visible';
            element.style.opacity = '1';
            element.style.position = 'absolute';
            element.style.zIndex = '9999';
            element.style.top = '100%';
            element.style.left = '0';
            element.style.right = '0';
            element.style.width = '100%';
        }
        
        // Helper function to hide dropdown (for old Android compatibility)
        function hideDropdown(element) {
            if (!element) return;
            removeClass(element, 'show');
            element.style.display = 'none';
            element.style.visibility = 'hidden';
            element.style.opacity = '0';
        }
        
        // Polyfill for Array.find (for IE11 and older)
        if (!supportsArrayFind) {
            Array.prototype.find = function(predicate) {
                if (this == null) {
                    throw new TypeError('Array.prototype.find called on null or undefined');
                }
                if (typeof predicate !== 'function') {
                    throw new TypeError('predicate must be a function');
                }
                var list = Object(this);
                var length = parseInt(list.length) || 0;
                var thisArg = arguments[1];
                var value;
                for (var i = 0; i < length; i++) {
                    value = list[i];
                    if (predicate.call(thisArg, value, i, list)) {
                        return value;
                    }
                }
                return undefined;
            };
        }
        
        // Polyfill for Array.includes (for IE11 and older)
        if (!supportsArrayIncludes) {
            Array.prototype.includes = function(searchElement) {
                var O = Object(this);
                var len = parseInt(O.length) || 0;
                if (len === 0) {
                    return false;
                }
                var n = parseInt(arguments[1]) || 0;
                var k;
                if (n >= 0) {
                    k = n;
                } else {
                    k = len + n;
                    if (k < 0) {
                        k = 0;
                    }
                }
                function sameValueZero(x, y) {
                    return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
                }
                for (; k < len; k++) {
                    if (sameValueZero(O[k], searchElement)) {
                        return true;
                    }
                }
                return false;
            };
        }
        
        // Fetch polyfill using XMLHttpRequest (for old browsers)
        if (!supportsFetch) {
            window.fetch = function(url, options) {
                return new Promise(function(resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    var method = (options && options.method) || 'GET';
                    var headers = (options && options.headers) || {};
                    var body = options && options.body;
                    
                    xhr.open(method, url);
                    
                    for (var key in headers) {
                        if (headers.hasOwnProperty(key)) {
                            xhr.setRequestHeader(key, headers[key]);
                        }
                    }
                    
                    xhr.onload = function() {
                        var response = {
                            ok: xhr.status >= 200 && xhr.status < 300,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            json: function() {
                                return Promise.resolve(JSON.parse(xhr.responseText));
                            },
                            text: function() {
                                return Promise.resolve(xhr.responseText);
                            }
                        };
                        if (response.ok) {
                            resolve(response);
                        } else {
                            reject(new Error('HTTP ' + xhr.status + ': ' + xhr.statusText));
                        }
                    };
                    
                    xhr.onerror = function() {
                        console.error('XHR error for URL:', url);
                        reject(new Error('Network error'));
                    };
                    
                    xhr.ontimeout = function() {
                        console.error('XHR timeout for URL:', url);
                        reject(new Error('Request timeout'));
                    };
                    
                    // Set timeout for old devices (30 seconds)
                    xhr.timeout = 30000;
                    
                    try {
                        xhr.send(body);
                    } catch (sendError) {
                        console.error('XHR send error:', sendError);
                        reject(new Error('Failed to send request: ' + sendError.message));
                    }
                });
            };
        }
        
        var cityInput = document.getElementById('city-input');
        var stateInput = document.getElementById('state-input');
        var countrySelect = document.getElementById('country-select');
        var countryInput = document.getElementById('country-input');
        var countryDropdown = document.getElementById('country-dropdown');
        var citySuggestions = document.getElementById('city-suggestions');
        var searchBtn = document.getElementById('search-btn');
        var formatFilter = document.getElementById('format-filter');
        var languageFilter = document.getElementById('language-filter');
        var container = document.getElementById('showtimes-container');
        
        // Debug: Check if elements are found
        if (!cityInput) {
            console.error('city-input not found');
        } else {
            console.log('‚úì city-input found');
        }
        if (!countryInput) {
            console.error('country-input not found');
        } else {
            console.log('‚úì country-input found');
        }
        if (!citySuggestions) {
            console.error('city-suggestions not found');
        } else {
            console.log('‚úì city-suggestions found');
        }
        if (!countryDropdown) {
            console.error('country-dropdown not found');
        } else {
            console.log('‚úì country-dropdown found');
        }
        
        // Verify fetch is available
        if (typeof fetch === 'undefined') {
            console.error('fetch is not available - polyfill may not have loaded');
        } else {
            console.log('‚úì fetch is available');
        }
        
        // Detect flag emoji support and show fallback on old Android devices
        (function() {
            var donateBtn = document.querySelector('.donate-btn');
            if (donateBtn) {
                var flagEmoji = donateBtn.querySelector('.flag-emoji');
                if (flagEmoji) {
                    // Check immediately and after a short delay
                    function checkFlagSupport() {
                        var emojiText = flagEmoji.textContent || flagEmoji.innerText || '';
                        // Check if emoji rendered as country code (old Android)
                        // On old Android, flag emojis render as "UA" text
                        // On modern browsers, they render as actual emoji characters (üá∫üá¶)
                        var isCountryCode = emojiText.trim() === 'UA' || emojiText.trim() === 'ua';
                        var hasFlagChars = emojiText.indexOf('üá∫') !== -1 || emojiText.indexOf('üá¶') !== -1;
                        var isEmpty = emojiText.trim() === '';
                        
                        // If it's showing as country code or empty (not rendering), use fallback
                        if (isCountryCode || (isEmpty && !hasFlagChars)) {
                            // Use helper functions for classList
                            addClass(donateBtn, 'flag-not-supported');
                            console.log('Flag emoji not supported, using fallback. Emoji text:', emojiText);
                        } else {
                            console.log('Flag emoji supported. Emoji text:', emojiText);
                        }
                    }
                    
                    // Check immediately
                    checkFlagSupport();
                    
                    // Check again after rendering (some browsers need time)
                    setTimeout(checkFlagSupport, 300);
                    setTimeout(checkFlagSupport, 1000);
                } else {
                    console.warn('Flag emoji element not found in donate button');
                }
            } else {
                console.warn('Donate button not found');
            }
        })();
        
        // For old devices: Show native select instead of custom dropdown
        // Since we have polyfills for fetch, only check for async/await support
        // But allow custom dropdowns even on old devices since we've converted everything to ES5
        var useNativeSelect = false; // Always use custom dropdowns - they work with polyfills
        if (useNativeSelect) {
            // Hide custom country input, show native select
            if (countryInput && countryInput.parentElement) {
                countryInput.parentElement.style.display = 'none';
            }
            if (countrySelect) {
                countrySelect.style.display = 'block';
            }
        } else {
            // Ensure custom dropdowns are visible
            if (countryInput && countryInput.parentElement) {
                countryInput.parentElement.style.display = '';
            }
            if (countrySelect) {
                countrySelect.style.display = 'none'; // Hide native select, use custom
            }
        }
        
        var currentCity = null;
        var currentCountry = null;
        var showtimes = [];
        var pollingInterval = null;
        var autocompleteTimeout = null;
        var skeletonTimeout = null;
        
        // Check if we're in a secure context (HTTPS required for geolocation)
        function isSecureContext() {
            return window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        }
        
        // Request browser geolocation and reverse geocode
        function requestLocationAndGeocode(showManualButton) {
            if (showManualButton === undefined) showManualButton = false;
            // Make sure elements exist
            if (!cityInput || !countryInput || !countrySelect) {
                console.error('Required elements not found for location geocoding');
                return;
            }
            if (!navigator.geolocation) {
                console.log('Geolocation is not supported by this browser');
                return;
            }
            
            // Check if we're in a secure context
            if (!isSecureContext()) {
                console.warn('Geolocation requires HTTPS. Current protocol:', location.protocol);
                // Don't show error on initial load, only if manually triggered
                if (showManualButton) {
                    showLocationError('Geolocation requires HTTPS. Please access this site over HTTPS (https://) to use location detection.');
                }
                return;
            }
            
            // Show a subtle indicator that we're requesting location
            var locationIndicator = document.createElement('div');
            locationIndicator.id = 'location-request-indicator';
            locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
            locationIndicator.textContent = 'üìç Requesting location...';
            document.body.appendChild(locationIndicator);
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    var lat = position.coords.latitude;
                    var lon = position.coords.longitude;
                    
                    // Reverse geocode coordinates to get city/country
                    fetch('/api/geocode', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ lat: lat, lon: lon })
                    }).then(function(response) {
                        return response.json();
                    }).then(function(data) {
                        if (data.success && data.city && data.country) {
            // Set city
                            cityInput.value = data.city;
                            if (data.region) {
                                if (cityInput.dataset) {
                                    cityInput.dataset.state = data.region;
                                } else {
                                    cityInput.setAttribute('data-state', data.region);
                                }
                                stateInput.value = data.region;
                            }
            
            // Set country
                            var countryName = data.country;
            countryInput.value = countryName;
            
            // Find and select the country in the dropdown
                            var countryOption = null;
                            var options = Array.from ? Array.from(countrySelect.options) : [];
                            if (!Array.from) {
                                // Fallback for old browsers
                                for (var i = 0; i < countrySelect.options.length; i++) {
                                    options.push(countrySelect.options[i]);
                                }
                            }
                            
                            for (var j = 0; j < options.length; j++) {
                                var opt = options[j];
                                if (opt.textContent.trim() === countryName) {
                                    countryOption = opt;
                                    break;
                                }
                            }
                            
            if (!countryOption) {
                                for (var k = 0; k < options.length; k++) {
                                    var opt2 = options[k];
                                    if (opt2.textContent.trim().toLowerCase() === countryName.toLowerCase()) {
                                        countryOption = opt2;
                                        break;
                                    }
                                }
                            }
                            
            if (!countryOption) {
                                for (var m = 0; m < options.length; m++) {
                                    var opt3 = options[m];
                                    var optText = opt3.textContent.trim().toLowerCase();
                                    var countryLower = countryName.toLowerCase();
                                    if (optText.indexOf(countryLower) !== -1 || countryLower.indexOf(optText) !== -1) {
                                        countryOption = opt3;
                                        break;
                                    }
                                }
            }
            
            if (countryOption) {
                countrySelect.value = countryOption.value;
                            }
                            
                            // Show auto-detected badge
                            var badge = document.getElementById('auto-detected-badge');
                            if (badge) {
                                badge.style.display = 'inline-block';
                            }
                            
                            // Update indicator
                            locationIndicator.textContent = '‚úì Location detected';
                            locationIndicator.style.background = 'rgba(39, 174, 96, 0.9)';
                            setTimeout(function() {
                                locationIndicator.remove();
                            }, 2000);
            } else {
                            // Browser geolocation succeeded but geocoding failed - fallback to IP
                            locationIndicator.textContent = 'üìç Trying IP-based location...';
                            requestLocationFromIP();
                        }
                    }).catch(function(error) {
                        console.error('Geocoding error:', error);
                        // Geocoding failed - fallback to IP
                        locationIndicator.textContent = 'üìç Trying IP-based location...';
                        requestLocationFromIP();
                    });
                },
                function(error) {
                    // User denied or error occurred - always try IP-based fallback
                    locationIndicator.textContent = 'üìç Trying IP-based location...';
                    locationIndicator.style.background = 'rgba(52, 152, 219, 0.9)';
                    requestLocationFromIP();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0  // Don't use cached position
                }
            );
        }
        
        // Helper function to show location error
        function showLocationError(message) {
            var locationIndicator = document.createElement('div');
            locationIndicator.id = 'location-request-indicator';
            locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(231, 76, 60, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 350px;';
            locationIndicator.textContent = '‚ö† ' + message;
            document.body.appendChild(locationIndicator);
            setTimeout(function() {
                locationIndicator.remove();
            }, 5000);
        }
        
        // IP-based geolocation fallback (no permission needed, works automatically)
        function requestLocationFromIP() {
            // Check if indicator already exists (from previous attempt)
            var locationIndicator = document.getElementById('location-request-indicator');
            if (!locationIndicator) {
                locationIndicator = document.createElement('div');
                locationIndicator.id = 'location-request-indicator';
                locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
                locationIndicator.textContent = 'üìç Detecting location...';
                document.body.appendChild(locationIndicator);
                } else {
                locationIndicator.textContent = 'üìç Detecting location...';
            }
            
            fetch('/api/geocode-ip').then(function(response) {
                return response.json();
            }).then(function(data) {
                if (data.success && data.city && data.country) {
                    // Set city
                    cityInput.value = data.city;
                    if (data.region) {
                        if (cityInput.dataset) {
                            cityInput.dataset.state = data.region;
                        } else {
                            cityInput.setAttribute('data-state', data.region);
                        }
                        stateInput.value = data.region;
                    }
                    
                    // Set country
                    var countryName = data.country;
                    countryInput.value = countryName;
                    
                    // Find and select the country in the dropdown
                    var countryOption = null;
                    var options = Array.from ? Array.from(countrySelect.options) : [];
                    if (!Array.from) {
                        // Fallback for old browsers
                        for (var i = 0; i < countrySelect.options.length; i++) {
                            options.push(countrySelect.options[i]);
                        }
                    }
                    
                    for (var j = 0; j < options.length; j++) {
                        var opt = options[j];
                        if (opt.textContent.trim() === countryName) {
                            countryOption = opt;
                            break;
                        }
                    }
                    
                    if (!countryOption) {
                        for (var k = 0; k < options.length; k++) {
                            var opt2 = options[k];
                            if (opt2.textContent.trim().toLowerCase() === countryName.toLowerCase()) {
                                countryOption = opt2;
                                break;
                            }
                        }
                    }
                    
                    if (!countryOption) {
                        for (var m = 0; m < options.length; m++) {
                            var opt3 = options[m];
                            var optText = opt3.textContent.trim().toLowerCase();
                            var countryLower = countryName.toLowerCase();
                            if (optText.indexOf(countryLower) !== -1 || countryLower.indexOf(optText) !== -1) {
                                countryOption = opt3;
                                break;
                            }
                        }
                    }
                    
                    if (countryOption) {
                        countrySelect.value = countryOption.value;
                    }
                    
                    // Show auto-detected badge
                    var badge = document.getElementById('auto-detected-badge');
                    if (badge) {
                        badge.style.display = 'inline-block';
                    }
                    
                    // Update indicator
                    locationIndicator.textContent = '‚úì Location detected';
                    locationIndicator.style.background = 'rgba(39, 174, 96, 0.9)';
                    setTimeout(function() {
                        locationIndicator.remove();
                    }, 2000);
                } else {
                    // Silently remove indicator if no location found
                    locationIndicator.remove();
                }
            }).catch(function(error) {
                console.error('IP geolocation error:', error);
                // Silently remove indicator on error
                locationIndicator.remove();
            });
        }
        
        // Auto-detect location on page load: Try browser geolocation first, fallback to IP
        function autoDetectLocation() {
            // Check if browser geolocation is available and we're in a secure context
            if (navigator.geolocation && isSecureContext()) {
                // Try browser geolocation first (more accurate)
                var locationIndicator = document.createElement('div');
                locationIndicator.id = 'location-request-indicator';
                locationIndicator.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(52, 152, 219, 0.9); color: white; padding: 0.75rem 1rem; border-radius: 5px; z-index: 10000; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.3); max-width: 300px;';
                locationIndicator.textContent = 'üìç Detecting location...';
                document.body.appendChild(locationIndicator);
                
                // Try browser geolocation with a short timeout
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        // Browser geolocation succeeded - remove indicator and let requestLocationAndGeocode handle it
                        locationIndicator.remove();
                        requestLocationAndGeocode(false);
                    },
                    function(error) {
                        // Browser geolocation failed - fallback to IP
                        locationIndicator.textContent = 'üìç Trying IP-based location...';
                        requestLocationFromIP();
                    },
                    {
                        enableHighAccuracy: false,  // Faster, less accurate is fine for initial detection
                        timeout: 5000,  // Short timeout - fallback quickly to IP
                        maximumAge: 60000  // Accept cached position up to 1 minute old
                    }
                );
            } else {
                // Browser geolocation not available or not in secure context - use IP directly
                requestLocationFromIP();
            }
        }
        
        // Auto-detect location on page load - wait for DOM to be ready and elements to exist
        function initAutoDetect() {
            // Make sure elements exist before trying to use them
            if (!cityInput || !countryInput) {
                console.log('Waiting for elements to be available...');
                setTimeout(initAutoDetect, 100);
                return;
            }
            setTimeout(autoDetectLocation, 500);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initAutoDetect();
            });
        } else {
            // DOM is already ready
            initAutoDetect();
        }
        
        // Add manual location button next to city input (for precise GPS location)
        var cityGroup = document.querySelector('.city-group');
        if (cityGroup) {
            var locationButton = document.createElement('button');
            locationButton.type = 'button';
            locationButton.id = 'manual-location-btn';
            locationButton.innerHTML = 'üìç';
            locationButton.title = 'Use precise GPS location (requires permission)';
            locationButton.setAttribute('aria-label', 'Use precise GPS location');
            locationButton.addEventListener('click', function() {
                if (!navigator.geolocation) {
                    showLocationError('Geolocation is not supported by your browser.');
                    return;
                }
                if (!isSecureContext()) {
                    showLocationError('Precise GPS location requires HTTPS. Please access this site over HTTPS (https://).');
                    return;
                }
                requestLocationAndGeocode(true);
            });
            
            var locationInputGroup = cityGroup.querySelector('.location-input-group');
            if (locationInputGroup) {
                locationInputGroup.appendChild(locationButton);
            }
        }
        
        // Clear auto-detected location when badge is clicked
        var autoDetectedBadge = document.getElementById('auto-detected-badge');
        if (autoDetectedBadge) {
            autoDetectedBadge.addEventListener('click', function() {
                // Clear city, state, and country inputs
                cityInput.value = '';
                stateInput.value = '';
                countryInput.value = '';
                countrySelect.value = '';
                delete cityInput.dataset.state;
                
                // Hide the badge
                autoDetectedBadge.style.display = 'none';
                
                // Focus on city input for user to type
                cityInput.focus();
            });
        }
        
        // Country dropdown will be populated dynamically from Nominatim when needed
        // No hardcoded list - rely on Nominatim for country names
        
        // Country search functionality (only for modern browsers)
        // Declare timeout variable in outer scope so it's accessible to handler
        var countrySearchTimeout = null;
        
        // Handler function for country input (works with both 'input' and 'keyup' events)
        function handleCountryInput(e) {
            var target = e.target || e.srcElement; // Support old browsers
            console.log('Country input event triggered, value:', target.value);
            var query = target.value.trim().toLowerCase();
            
            if (countrySearchTimeout) {
                clearTimeout(countrySearchTimeout);
            }
            
            // Reset selection when input changes
            selectedCountryIndex = -1;
            
            if (query.length === 0) {
                hideDropdown(countryDropdown);
                countrySelect.value = '';
                selectedCountryIndex = -1;
                return;
            }
            
            countrySearchTimeout = setTimeout(function() {
                // Use Nominatim to search for countries
                if (query.length < 2) {
                    hideDropdown(countryDropdown);
                    return;
                }
                
                // Search Nominatim for countries matching the query
                fetch('/api/city-suggestions?q=' + encodeURIComponent(query) + '&lang=en', {
                    headers: { 'Accept': 'application/json' }
                }).then(function(response) {
                    if (!response.ok) {
                        hideDropdown(countryDropdown);
                        return [];
                    }
                    return response.json();
                }).then(function(results) {
                    // Extract unique countries from results
                    var countries = [];
                    var countrySet = {};
                    for (var i = 0; i < results.length && countries.length < 10; i++) {
                        var result = results[i];
                        var address = result.address || {};
                        var country = address.country || '';
                        if (country && !countrySet[country.toLowerCase()]) {
                            countrySet[country.toLowerCase()] = true;
                            countries.push(country);
                        }
                    }
                    
                    countryDropdown.innerHTML = '';
                    if (countries.length === 0) {
                        hideDropdown(countryDropdown);
                        return;
                    }
                    
                    for (var j = 0; j < countries.length; j++) {
                        var country = countries[j];
                        var div = document.createElement('div');
                        div.className = 'country-option';
                        div.textContent = country;
                        
                        // Function to select this country (used by both click and keyboard)
                        var selectCountry = function(countryName) {
                            return function() {
                                countryInput.value = countryName;
                                countrySelect.value = countryName;
                                hideDropdown(countryDropdown);
                                selectedCountryIndex = -1; // Reset selection
                            };
                        }(country);
                        
                        div.addEventListener('click', selectCountry);
                        countryDropdown.appendChild(div);
                    }
                    
                    showDropdown(countryDropdown);
                    selectedCountryIndex = -1; // Reset selection when new suggestions are shown
                }).catch(function(error) {
                    console.error('Error fetching country suggestions:', error);
                    hideDropdown(countryDropdown);
                });
            }, 200);
            }
        
        if (!useNativeSelect && countryInput) {
            console.log('‚úì Country input event listener attached');
            // Use 'input' event for modern browsers
            if (countryInput.addEventListener) {
                countryInput.addEventListener('input', handleCountryInput, false);
                // Fallback to 'keyup' for old Android devices that don't support 'input' event properly
                countryInput.addEventListener('keyup', function(e) {
                    // Only trigger on character keys (not arrow keys, etc.)
                    var key = e.keyCode || e.which;
                    if (key >= 32 && key <= 126 || key === 8 || key === 46) { // Printable chars, backspace, delete
                        handleCountryInput(e);
                    }
                }, false);
            } else if (countryInput.attachEvent) {
                // IE8 and older
                countryInput.attachEvent('onkeyup', handleCountryInput);
            }
        }
        
        // Keyboard navigation for country suggestions
        countryInput.addEventListener('keydown', function(e) {
            var countryOptions = countryDropdown.querySelectorAll('.country-option');
            
            if (!hasClass(countryDropdown, 'show') || countryOptions.length === 0) {
                // If suggestions are not visible, allow Enter key to work normally
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedCountryIndex = (selectedCountryIndex + 1) % countryOptions.length;
                    updateCountrySelection(countryOptions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedCountryIndex = selectedCountryIndex <= 0 
                        ? countryOptions.length - 1 
                        : selectedCountryIndex - 1;
                    updateCountrySelection(countryOptions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedCountryIndex >= 0 && selectedCountryIndex < countryOptions.length) {
                        countryOptions[selectedCountryIndex].click();
                    } else {
                        // If no selection, close dropdown
                        hideDropdown(countryDropdown);
                        selectedCountryIndex = -1;
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    hideDropdown(countryDropdown);
                    selectedCountryIndex = -1;
                    break;
            }
        });
        
        // Allow selecting from native select (for old browsers and keyboard users)
        if (countrySelect) {
            countrySelect.addEventListener('change', function(e) {
                if (e.target.value && !useNativeSelect && countryInput) {
                    countryInput.value = e.target.value;
                }
            });
        }
        
        // City autocomplete using OpenStreetMap Nominatim (free API)
        // Handler function for city input (works with both 'input' and 'keyup' events)
        function handleCityInput(e) {
            var target = e.target || e.srcElement; // Support old browsers
            console.log('City input event triggered, value:', target.value);
            var query = target.value.trim();
            
            // Clear previous timeout
            if (autocompleteTimeout) {
                clearTimeout(autocompleteTimeout);
            }
            
            if (query.length < 2) {
                if (citySuggestions) {
                    hideDropdown(citySuggestions);
                }
                return;
            }
            
            // Debounce API calls (500ms delay)
            autocompleteTimeout = setTimeout(function() {
                console.log('Calling fetchCitySuggestions for:', query);
                fetchCitySuggestions(query);
            }, 500);
        }
        
        if (cityInput) {
            console.log('‚úì City input event listener attached');
            // Use 'input' event for modern browsers
            if (cityInput.addEventListener) {
                cityInput.addEventListener('input', handleCityInput, false);
                // Fallback to 'keyup' for old Android devices that don't support 'input' event properly
                cityInput.addEventListener('keyup', function(e) {
                    // Only trigger on character keys (not arrow keys, etc.)
                    var key = e.keyCode || e.which;
                    if (key >= 32 && key <= 126 || key === 8 || key === 46) { // Printable chars, backspace, delete
                        handleCityInput(e);
                    }
                }, false);
            } else if (cityInput.attachEvent) {
                // IE8 and older
                cityInput.attachEvent('onkeyup', handleCityInput);
            }
        } else {
            console.error('City input not found - cannot attach event listener');
        }
        
        function fetchCitySuggestions(query) {
            if (!citySuggestions) {
                console.error('City suggestions element not found');
                return;
            }
            
            // Use backend proxy to avoid CORS issues on old browsers
            var url = '/api/city-suggestions?q=' + encodeURIComponent(query) + '&lang={{ lang }}';
            
            console.log('Fetching city suggestions for:', query);
            console.log('Fetch available:', typeof fetch !== 'undefined');
            console.log('Promise available:', typeof Promise !== 'undefined');
            console.log('Using backend proxy URL:', url);
            
            try {
                fetch(url).then(function(response) {
                    console.log('Fetch response received, status:', response.status);
                if (!response.ok) {
                        console.error('API error:', response.status, response.statusText);
                        if (citySuggestions) {
                            hideDropdown(citySuggestions);
                        }
                        return [];
                    }
                    return response.json();
                }).then(function(results) {
                    if (!results || results.length === 0) {
                        console.log('No results from API');
                        if (citySuggestions) {
                            hideDropdown(citySuggestions);
                        }
                    return;
                }
                
                    console.log('Received', results.length, 'results from API');
                    console.log('Query was:', query);
                    if (results.length > 0) {
                        console.log('First result:', results[0].display_name, '- City:', (results[0].address && (results[0].address.city || results[0].address.town)) || 'N/A');
                    }
                
                // Helper function to extract city name from result
                function getCityName(result) {
                    var address = result.address || {};
                    var displayName = result.display_name || '';
                    
                    // Try to get city name from address first
                    var cityName = address.city || address.town || address.village || address.municipality || '';
                    
                    // If no city in address, try to extract from display_name (format: "City, State, Country")
                    if (!cityName && displayName) {
                        var parts = displayName.split(',');
                        if (parts.length > 0) {
                            cityName = parts[0].trim();
                        }
                    }
                    
                    return cityName || displayName;
                }
                
                // Helper function to normalize query for matching (remove spaces, handle partial words)
                function normalizeForMatch(text) {
                    return text.toLowerCase().replace(/\s+/g, '');
                }
                
                // Helper function to check if query matches (handles partial word matches)
                function queryMatches(text, query) {
                    var textLower = text.toLowerCase();
                    var queryLower = query.toLowerCase();
                    
                    // Direct match
                    if (textLower.indexOf(queryLower) !== -1) {
                        return true;
                    }
                    
                    // Check if query matches when spaces are removed (e.g., "los ang" matches "los angeles")
                    var textNoSpaces = textLower.replace(/\s+/g, '');
                    var queryNoSpaces = queryLower.replace(/\s+/g, '');
                    if (textNoSpaces.indexOf(queryNoSpaces) !== -1) {
                        return true;
                    }
                    
                    // Check word-by-word prefix match (e.g., "los ang" matches "los angeles")
                    var textWords = textLower.split(/\s+/);
                    var queryWords = queryLower.split(/\s+/);
                    if (queryWords.length > 0) {
                        var firstQueryWord = queryWords[0];
                        var matchesFirstWord = false;
                        for (var w = 0; w < textWords.length; w++) {
                            if (textWords[w].indexOf(firstQueryWord) === 0) {
                                matchesFirstWord = true;
                                break;
                            }
                        }
                        if (matchesFirstWord && queryWords.length > 1) {
                            // Check if subsequent query words match
                            var allMatch = true;
                            for (var q = 1; q < queryWords.length && q < textWords.length; q++) {
                                if (textWords[q].indexOf(queryWords[q]) !== 0) {
                                    allMatch = false;
                                    break;
                                }
                            }
                            if (allMatch) {
                                return true;
                            }
                        }
                    }
                    
                    return false;
                }
                
                // Include all results from Nominatim - trust its relevance
                var displayResults = [];
                for (var i = 0; i < results.length && i < 10; i++) {
                    var result = results[i];
                    var placeType = result.type || '';
                    var placeClass = result.class || '';
                    var shouldInclude = false;
                    
                    // Include cities, towns, villages, municipalities, and administrative areas
                    if (placeType.indexOf('city') !== -1 || 
                        placeType.indexOf('town') !== -1 || 
                        placeType.indexOf('village') !== -1 || 
                        placeType.indexOf('municipality') !== -1 ||
                        placeType.indexOf('administrative') !== -1 ||
                           placeClass === 'place' ||
                        (result.address && (result.address.city || result.address.town || result.address.village || result.address.municipality))) {
                        shouldInclude = true;
                    }
                    
                    if (shouldInclude) {
                        displayResults.push(result);
                        console.log('Suggestion', displayResults.length, ':', getCityName(result), '- Display:', result.display_name);
                    }
                }
                
                console.log('Total results to display:', displayResults.length);
                
                // Always show results if we have any (even if scores are low)
                if (displayResults.length === 0) {
                    console.log('No results to display for query:', query);
                    if (citySuggestions) {
                        hideDropdown(citySuggestions);
                    }
                    return;
                }
                
                console.log('Displaying', displayResults.length, 'city suggestions (sorted by relevance)');
                displayCitySuggestions(displayResults);
                }).catch(function(e) {
                console.error('Autocomplete error:', e);
                    console.error('Error details:', e.message, e.stack);
                    console.error('Error type:', typeof e);
                    if (citySuggestions) {
                        hideDropdown(citySuggestions);
                        citySuggestions.innerHTML = '<div class="suggestion-item" style="color: #e74c3c; padding: 0.75rem;">Error loading suggestions. Please check your connection.</div>';
                        showDropdown(citySuggestions);
                        setTimeout(function() {
                            hideDropdown(citySuggestions);
                        }, 3000);
                    }
                });
            } catch (error) {
                console.error('Failed to initiate fetch:', error);
                console.error('Error type:', typeof error);
                if (citySuggestions) {
                    hideDropdown(citySuggestions);
                    citySuggestions.innerHTML = '<div class="suggestion-item" style="color: #e74c3c; padding: 0.75rem;">Browser does not support fetching. Please update your browser.</div>';
                    showDropdown(citySuggestions);
                    setTimeout(function() {
                        hideDropdown(citySuggestions);
                    }, 3000);
                }
            }
        }
        
        function displayCitySuggestions(results) {
            if (!citySuggestions) {
                console.error('City suggestions element not found in displayCitySuggestions');
                return;
            }
            
            console.log('displayCitySuggestions called with', results.length, 'results');
            
            if (results.length === 0) {
                console.log('No results to display, hiding suggestions');
                hideDropdown(citySuggestions);
                if (citySuggestions) citySuggestions.style.display = 'none';
                selectedSuggestionIndex = -1;
                return;
            }
            
            citySuggestions.innerHTML = '';
            selectedSuggestionIndex = -1; // Reset selection when new suggestions are shown
            
            console.log('Creating', results.length, 'suggestion items');
            
            for (var i = 0; i < results.length; i++) {
                var result = results[i];
                var div = document.createElement('div');
                div.className = 'suggestion-item';
                
                // Extract city, state, and country from Nominatim API response
                // Prefer structured address object over parsing display_name
                var cityName = '';
                var stateName = '';
                var countryName = '';
                
                if (result.address) {
                    // Use structured address data (more reliable)
                    cityName = result.address.city || 
                              result.address.town || 
                              result.address.village || 
                              result.address.municipality ||
                              result.address.county ||
                              '';
                    
                    // State/province can be in different fields
                    stateName = result.address.state || 
                               result.address.province || 
                               result.address.region ||
                               result.address.state_district ||
                               '';
                    
                    countryName = result.address.country || '';
                }
                
                // Fallback to parsing display_name if address object is incomplete
                if (!cityName || !countryName) {
                    var parts = result.display_name.split(', ');
                    if (!cityName) {
                        cityName = parts[0];
                    }
                    if (!countryName) {
                        countryName = parts[parts.length - 1];
                    }
                    if (!stateName && parts.length >= 3) {
                        stateName = parts.slice(1, -1).join(', ');
                    }
                }
                
                // Clean up extracted values
                cityName = cityName.trim();
                stateName = stateName.trim();
                countryName = countryName.trim();
                
                // Build display text
                var displayText = cityName;
                if (stateName) {
                    displayText += ' <small>(' + stateName + ', ' + countryName + ')</small>';
                } else {
                    displayText += ' <small>(' + countryName + ')</small>';
                }
                
                div.innerHTML = displayText;
                
                // Store full location data in data attributes
                div.setAttribute('data-city', cityName);
                div.setAttribute('data-state', stateName);
                div.setAttribute('data-country', countryName);
                
                // Function to select this suggestion (used by both click and keyboard)
                var selectSuggestion = (function(city, state, country) {
                    return function() {
                        // Set state in dataset and input FIRST to prevent input event listener from clearing it
                        if (state && state.length > 0) {
                            if (cityInput.dataset) {
                                cityInput.dataset.state = state;
                            } else {
                                cityInput.setAttribute('data-state', state);
                            }
                            stateInput.value = state;
                        } else {
                            if (cityInput.dataset) {
                                delete cityInput.dataset.state;
                            } else {
                                cityInput.removeAttribute('data-state');
                            }
                            stateInput.value = '';
                        }
                        
                        // Set city name (this will trigger input event, but dataset.state is already set)
                        cityInput.value = city;
                    
                    // Try to match and select the country
                    // Nominatim should return normalized country names, but try to match to dropdown list
                    function normalizeCountryName(name) {
                        return name.toLowerCase()
                            .replace(/\s+/g, ' ')
                            .trim();
                    }
                    
                    // Use Nominatim's country name directly (already normalized)
                    countryInput.value = country;
                    countrySelect.value = country;
                    console.log('‚úì Using Nominatim country name: "' + country + '"');
                    
                    // State is already set above before cityInput.value was set
                    if (state && state.length > 0) {
                        console.log('‚úì State stored: "' + state + '"');
                    }
                    
                    // Log summary for debugging
                    console.log('Selected location: City="' + city + '", State="' + (state || '(none)') + '", Country="' + country + '"');
                    
                    // Close suggestions
                        hideDropdown(citySuggestions);
                    if (citySuggestions) citySuggestions.style.display = 'none';
                    selectedSuggestionIndex = -1;
                };
                }(cityName, stateName, countryName));
                
                div.addEventListener('click', selectSuggestion);
                
                citySuggestions.appendChild(div);
            }
            
            // Show the suggestions dropdown
            console.log('Showing suggestions dropdown');
            addClass(citySuggestions, 'show');
            // Aggressive inline styles for old Android devices
            citySuggestions.style.display = 'block';
            citySuggestions.style.visibility = 'visible';
            citySuggestions.style.opacity = '1';
            citySuggestions.style.position = 'absolute';
            citySuggestions.style.zIndex = '9999';
            citySuggestions.style.top = '100%';
            citySuggestions.style.left = '0';
            citySuggestions.style.right = '0';
            citySuggestions.style.width = '100%';
            console.log('Suggestions dropdown should now be visible, display:', citySuggestions.style.display);
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!cityInput.contains(e.target) && !citySuggestions.contains(e.target)) {
                hideDropdown(citySuggestions);
                if (citySuggestions) citySuggestions.style.display = 'none';
            }
        });
        
        // Search button click handler
        searchBtn.addEventListener('click', function() {
            var city = cityInput.value.trim();
            // Get country from select first, fallback to input if select is empty
            var country = countrySelect.value;
            if (!country && countryInput.value.trim()) {
                // If select is empty but input has value, try to match it
                var countryInputValue = countryInput.value.trim();
                var matchedOption = null;
                // Convert options to array (using polyfill if needed)
                var options = Array.from ? Array.from(countrySelect.options) : [];
                if (!Array.from) {
                    for (var i = 0; i < countrySelect.options.length; i++) {
                        options.push(countrySelect.options[i]);
                    }
                }
                // Find matching option
                for (var j = 0; j < options.length; j++) {
                    var opt = options[j];
                    if (opt.textContent.trim() === countryInputValue || opt.value === countryInputValue) {
                        matchedOption = opt;
                        break;
                    }
                }
                if (matchedOption) {
                    country = matchedOption.value;
                    countrySelect.value = country;
                } else {
                    // Use the input value directly if no match found
                    country = countryInputValue;
                }
            }
            // Get state from input field first, fallback to dataset
            var state = stateInput.value.trim() || (cityInput.dataset && cityInput.dataset.state) || '';
            
            // Hide suggestions
            hideDropdown(citySuggestions);
            
            // Clear any existing polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            // Basic validation first
            if (!city) {
                showEmptyState('Please enter a city name', 'üèôÔ∏è');
                return;
            }
            
            if (!country) {
                showEmptyState('Please select a country', 'üåç');
                return;
            }
            
            // Location validation is now handled by backend /api/scrape endpoint
            // Proceed directly with search
            currentCity = city;
            currentCountry = country;
            
            showLoadingSkeleton();
            
            // Always trigger scrape directly - backend will handle API key check and return existing data if fresh
            // This ensures API key check happens on every search attempt
            fetchShowtimes(city, country, state);
        });
        
        // Keyboard navigation for city and country suggestions
        var selectedSuggestionIndex = -1;
        var selectedCountryIndex = -1;
        
        cityInput.addEventListener('keydown', function(e) {
            var suggestions = citySuggestions.querySelectorAll('.suggestion-item');
            
            if (!hasClass(citySuggestions, 'show') || suggestions.length === 0) {
                // If suggestions are not visible, handle Enter key to search
                if (e.key === 'Enter') {
                    e.preventDefault();
                    hideDropdown(citySuggestions);
                    if (citySuggestions) citySuggestions.style.display = 'none';
                    searchBtn.click();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedSuggestionIndex = (selectedSuggestionIndex + 1) % suggestions.length;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedSuggestionIndex = selectedSuggestionIndex <= 0 
                        ? suggestions.length - 1 
                        : selectedSuggestionIndex - 1;
                    updateSuggestionSelection(suggestions);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < suggestions.length) {
                        // Get the selected suggestion's data
                        var selectedItem = suggestions[selectedSuggestionIndex];
                        var cityName = selectedItem.dataset.city;
                        var stateName = selectedItem.dataset.state || '';
                        var countryName = selectedItem.dataset.country;
                        
                        // Set state in dataset and input FIRST to prevent input event listener from clearing it
                        if (stateName && stateName.length > 0) {
                            cityInput.dataset.state = stateName;
                            stateInput.value = stateName;
                        } else {
                            delete cityInput.dataset.state;
                            stateInput.value = '';
                        }
                        
                        // Set city name (this will trigger input event, but dataset.state is already set)
                        cityInput.value = cityName;
                        
                        // Use the same country matching logic as click handler
                        var normalizeCountryName = function(name) {
                            return name.toLowerCase()
                                .replace(/\s+/g, ' ')
                                .trim();
                        };
                        
                        var countryLower = normalizeCountryName(countryName);
                        
                        // Common country name mappings
                        // Try to match country to dropdown list
                        // Nominatim should return normalized country names
                        // Use Nominatim's country name directly (already normalized)
                        countryInput.value = countryName;
                        countrySelect.value = countryName;
                        console.log('‚úì Using Nominatim country name: "' + countryName + '"');
                        
                        // State is already set above before cityInput.value was set
                        
                        hideDropdown(citySuggestions);
                    if (citySuggestions) citySuggestions.style.display = 'none';
                        selectedSuggestionIndex = -1;
                    } else {
                        hideDropdown(citySuggestions);
                    if (citySuggestions) citySuggestions.style.display = 'none';
                        searchBtn.click();
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    hideDropdown(citySuggestions);
                    selectedSuggestionIndex = -1;
                    break;
            }
        });
        
        function updateSuggestionSelection(suggestions) {
            for (var idx = 0; idx < suggestions.length; idx++) {
                var item = suggestions[idx];
                var index = idx;
                if (index === selectedSuggestionIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.classList.remove('selected');
                }
            }
        }
        
        // Clear state when city input changes manually
        function handleCityInputClear(e) {
            var target = e.target || e.srcElement; // Support old browsers
            // Check if dataset exists (old browsers might not support it)
            if (target.dataset && !target.dataset.state) {
                // Only clear if user is typing (not from autocomplete selection)
                delete target.dataset.state;
                if (stateInput) stateInput.value = '';
            } else if (!target.dataset) {
                // Old browser - use getAttribute instead
                if (!target.getAttribute('data-state')) {
                    if (stateInput) stateInput.value = '';
                }
            }
        }
        
        if (cityInput && cityInput.addEventListener) {
            cityInput.addEventListener('input', handleCityInputClear, false);
            // Fallback for old devices
            cityInput.addEventListener('keyup', function(e) {
                var key = e.keyCode || e.which;
                if (key >= 32 && key <= 126 || key === 8 || key === 46) {
                    handleCityInputClear(e);
                }
            }, false);
        }
        
        // Sync state input with dataset when manually changed
        function handleStateInput(e) {
            var target = e.target || e.srcElement; // Support old browsers
            var stateValue = target.value.trim();
            if (stateValue) {
                // Store in dataset if supported, otherwise use attribute
                if (cityInput && cityInput.dataset) {
                cityInput.dataset.state = stateValue;
                } else if (cityInput) {
                    cityInput.setAttribute('data-state', stateValue);
                }
            } else {
                // Clear state
                if (cityInput && cityInput.dataset) {
                delete cityInput.dataset.state;
                } else if (cityInput) {
                    cityInput.removeAttribute('data-state');
                }
            }
        }
        
        if (stateInput && stateInput.addEventListener) {
            stateInput.addEventListener('input', handleStateInput, false);
            // Fallback for old devices
            stateInput.addEventListener('keyup', function(e) {
                var key = e.keyCode || e.which;
                if (key >= 32 && key <= 126 || key === 8 || key === 46) {
                    handleStateInput(e);
                }
            }, false);
        }
        
        function fetchShowtimes(city, country, state) {
            if (!state) state = '';
            
            var locationId = state ? city + ', ' + state + ', ' + country : city + ', ' + country;
            
            fetch('/api/scrape', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    city: city, 
                    country: country,
                    state: state
                })
            }).then(function(response) {
                return response.json().then(function(data) {
                    // Handle 202 - scraping in progress
                    if (response.status === 202) {
                        showLoadingState('Scraping showtimes');
                        startPolling(locationId);
                        return;
                    }
                    
                    // Handle errors
                    if (!response.ok || data.status === 'error') {
                        hideLoadingOverlay();
                        var errorMsg = data.message || data.error || data.error_message || 'An error occurred while fetching showtimes.';
                        if (data.error_type === 'api_key_error') {
                            errorMsg = 'Anthropic API key is not configured or invalid. Please check your ANTHROPIC_API_KEY environment variable.';
                        } else if (data.error_type === 'location_verification_failed') {
                            errorMsg = errorMsg || 'Location not found. Please verify the city, state, and country names are correct.';
                        }
                        showErrorState(errorMsg);
                        return;
                    }
                    
                    // Handle success - show showtimes if available
                    if (data.showtimes && Array.isArray(data.showtimes) && data.showtimes.length > 0) {
                        hideLoadingOverlay();
                        showtimes = applyFilters(data.showtimes);
                        renderShowtimes();
                        return;
                    }
                    
                    // If no showtimes but status is success/fresh, load them
                    if (data.status === 'success' || data.status === 'fresh') {
                        hideLoadingOverlay();
                        loadShowtimes(locationId);
                        return;
                    }
                    
                    // Otherwise, start polling
                    showLoadingState('Processing request...');
                    startPolling(locationId);
                });
            }).catch(function(e) {
                console.error('fetchShowtimes - Request failed:', e);
                hideLoadingOverlay();
                showErrorState('Error connecting to server. Please check your internet connection.');
            });
        }
        
        function startPolling(locationId) {
            var pollCount = 0;
            // Poll every 2 seconds for status updates
            pollingInterval = setInterval(function() {
                    pollCount++;
                var dataLoaded = false;
                    
                    // FIRST: Check if showtimes are available (even during daily refresh)
                    // Always try to load data first - if it exists, show it immediately
                var params = 'city_name=' + encodeURIComponent(locationId);
                if (formatFilter.value) params += '&format=' + encodeURIComponent(formatFilter.value);
                if (languageFilter.value) params += '&language=' + encodeURIComponent(languageFilter.value);
                
                // Fetch both showtimes and status in parallel
                fetch('/api/showtimes?' + params).then(function(testResponse) {
                    return testResponse.json();
                }).then(function(testShowtimes) {
                    // Also fetch status
                    return fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusResponse) {
                        return statusResponse.json().then(function(statusData) {
                        // If we got showtimes (even if daily refresh is running), display them immediately
                        // BUT: Check status first - if status is 'error', show error instead of empty state
                        if (testShowtimes && Array.isArray(testShowtimes)) {
                            // Check status to see if there was an error BEFORE checking showtimes
                            if (statusData.status === 'error') {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                hideLoadingOverlay();
                                    var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                    showErrorState(errorMsg);
                                return;
                            }
                            
                            clearInterval(pollingInterval);
                            pollingInterval = null;
                            hideLoadingOverlay(); // Stop animation immediately
                            if (testShowtimes.length > 0) {
                                showtimes = applyFilters(testShowtimes);
                                renderShowtimes(); // Display available data
                            } else {
                                // Data is ready but no showtimes found (only if not error status)
                                showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                            }
                            return; // Exit, don't continue polling
                    }
                    
                    // If data was loaded, we already returned above
                    // Now check status for fresh/ready data
                    if (statusData.status === 'fresh' || statusData.ready) {
                        // Data is ready! Stop polling and load showtimes immediately
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay(); // Stop animation before loading
                                loadShowtimes(locationId);
                        return; // Exit early, don't continue polling
                    }
                    
                    // Only show loading state if we're still waiting (no data available yet)
                        // Update UI with current status (dots will be animated)
                            var statusMessage = statusData.processing_by === 'on-demand' 
                            ? 'Scraping showtimes' 
                            : (statusData.processing_by === 'daily-refresh' 
                                ? 'Daily refresh in progress' 
                                : 'Processing');
                        showLoadingState(statusMessage);
                    
                    if (statusData.status === 'stale' || statusData.status === 'error') {
                        // Scraping failed, stop polling
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay();
                        
                        // Always show error state for 'error' status, never show "no showtimes"
                        if (statusData.status === 'error') {
                                    var errorMsg2 = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                                    showErrorState(errorMsg2);
                        } else {
                            // Only show "no showtimes" for 'stale' status (not error)
                                    var errorMsg3 = statusData.message || '{{ translations.no_showtimes or "No showtimes found" }}';
                                    showEmptyState(errorMsg3, 'üé¨');
                        }
                    }
                    // Otherwise keep polling (status is 'processing')
                        });
                    });
                }).catch(function(e) {
                    console.error('Polling error:', e);
                    // After too many errors, stop polling and show error
                    if (pollCount > 30) { // 30 polls = 60 seconds
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        hideLoadingOverlay();
                        showErrorState('Request timed out. Please try again.');
                    }
                    // Otherwise continue polling on error (network issues, etc.)
                });
            }, 2000); // Poll every 2 seconds
        }
        
        function loadShowtimes(locationId) {
            var params = 'city_name=' + encodeURIComponent(locationId);
            if (formatFilter.value) params += '&format=' + encodeURIComponent(formatFilter.value);
            if (languageFilter.value) params += '&language=' + encodeURIComponent(languageFilter.value);
            
                // First check status to see if there's an error
            fetch('/api/scrape/status/' + encodeURIComponent(locationId)).then(function(statusResponse) {
                return statusResponse.json().then(function(statusData) {
                // If status is error, show error message instead of loading showtimes
                if (statusData.status === 'error') {
                    hideLoadingOverlay();
                        var errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                        showErrorState(errorMsg);
                    return;
                }
                
                    // Load showtimes
                    return fetch('/api/showtimes?' + params).then(function(response) {
                        return response.json().then(function(showtimesData) {
                            showtimes = showtimesData;
                // Stop animation and render results
                hideLoadingOverlay();
                renderShowtimes();
                        });
                    });
                });
            }).catch(function(e) {
                console.error('Error loading showtimes:', e);
                // Stop animation on error
                hideLoadingOverlay();
                showErrorState('Error loading showtimes. Please try again.');
            });
        }
        
        function applyFilters(data) {
            let filtered = [...data];
            
            // Filter out past showtimes first (before other filters)
            const now = new Date();
            filtered = filtered.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (formatFilter.value) {
                filtered = filtered.filter(s => s.format && s.format === formatFilter.value);
            }
            if (languageFilter.value) {
                filtered = filtered.filter(s => 
                    (s.language || '').toLowerCase().includes(languageFilter.value.toLowerCase())
                );
            }
            
            // Sort by start_time (ascending - earliest first)
            filtered.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            return filtered;
        }
        
        // Helper functions for UI states
        function showLoadingSkeleton() {
            // Clear any existing skeleton timeout
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Show spinner first, then skeleton after a brief moment
            showLoadingState('Preparing to load showtimes...');
            skeletonTimeout = setTimeout(() => {
                // Only show skeleton if we're still loading (no error/result shown yet)
                if (container.querySelector('.loading-skeleton') === null && 
                    container.querySelector('.error-state') === null &&
                    container.querySelector('.empty-state') === null) {
                    container.innerHTML = `
                        <div class="loading-skeleton">
                            ${Array(6).fill(0).map(() => `
                                <div class="skeleton-card">
                                    <div class="skeleton-image"></div>
                                    <div class="skeleton-content">
                                        <div class="skeleton-line short"></div>
                                        <div class="skeleton-line medium"></div>
                                        <div class="skeleton-line"></div>
                                        <div class="skeleton-line short"></div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                skeletonTimeout = null;
            }, 500);
        }
        
        function clearLoadingSkeleton() {
            // Clear skeleton timeout if it exists
            if (skeletonTimeout) {
                clearTimeout(skeletonTimeout);
                skeletonTimeout = null;
            }
            // Remove skeleton from DOM if present
            const skeleton = container.querySelector('.loading-skeleton');
            if (skeleton) {
                skeleton.remove();
            }
        }
        
        function showLoadingState(message = 'Loading...') {
            // Create or update full-page loading overlay
            let overlay = document.getElementById('loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'loading-overlay';
                overlay.className = 'loading-overlay';
                document.body.appendChild(overlay);
            }
            
            overlay.innerHTML = `
                <div class="loading-overlay-content">
                    <div class="spinner-glow">
                        <span style="font-size: 24px; color: var(--accent); text-shadow: 0 0 10px rgba(52, 152, 219, 0.8);">üé¨</span>
                    </div>
                    <p class="loading-text">${message}<span class="loading-dots"></span></p>
                    <p>Please wait while we fetch the latest showtimes...</p>
                </div>
            `;
            
            // Show overlay with animation
            setTimeout(() => {
                overlay.classList.add('show');
            }, 10);
        }
        
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                // Remove overlay after animation
                setTimeout(() => {
                    if (overlay && !hasClass(overlay, 'show')) {
                        overlay.remove();
                    }
                }, 300);
            }
        }
        
        function showEmptyState(message, icon = 'üé¨') {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing empty state
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">${icon}</div>
                    <h3>${message}</h3>
                    <p>Try searching for a different city or check back later</p>
                </div>
            `;
        }
        
        function showErrorState(message, retryCallback = null) {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when showing error state
            const errorHtml = `
                <div class="error-state">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <h3>Something went wrong</h3>
                    <p>${message}</p>
                    ${retryCallback ? '<button class="retry-btn" id="retry-btn">Retry</button>' : ''}
                </div>
            `;
            container.innerHTML = errorHtml;
            
            if (retryCallback) {
                const retryBtn = document.getElementById('retry-btn');
                if (retryBtn) {
                    retryBtn.addEventListener('click', retryCallback);
                }
            }
        }
        
        async function renderShowtimes() {
            hideLoadingOverlay();
            clearLoadingSkeleton(); // Clear skeleton when rendering showtimes
            if (!showtimes || showtimes.length === 0) {
                // Before showing "No showtimes", check if there's an error status
                try {
                    const city = cityInput.value.trim();
                    const country = countrySelect.value;
                    const state = stateInput.value.trim() || cityInput.dataset.state || '';
                    if (city && country) {
                        const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                        const statusResponse = await fetch(`/api/scrape/status/${encodeURIComponent(locationId)}`);
                        const statusData = await statusResponse.json();
                        
                        // If status is error, show error message instead of "no showtimes"
                        if (statusData.status === 'error') {
                            const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                            showErrorState(errorMsg, () => {
                                if (city && country) {
                                    fetchShowtimes(city, country, state);
                                }
                            });
                            return;
                        }
                    }
                } catch (e) {
                    // If status check fails, continue to show empty state
                    console.log('Could not check status:', e);
                }
                showEmptyState('{{ translations.no_showtimes or "No showtimes found" }}', 'üé¨');
                return;
            }
            
            // Filter out past showtimes on frontend (additional safety check)
            const now = new Date();
            const futureShowtimes = showtimes.filter(st => {
                if (!st || !st.start_time) return false;
                try {
                    const startTime = new Date(st.start_time);
                    // Check if date is valid
                    if (isNaN(startTime.getTime())) return false;
                    return startTime > now;
                } catch (e) {
                    // Invalid date, skip this showtime
                    return false;
                }
            });
            
            if (futureShowtimes.length === 0) {
                // Before showing "No upcoming showtimes", check if there's an error status
                try {
                    const city = cityInput.value.trim();
                    const country = countrySelect.value;
                    const state = stateInput.value.trim() || cityInput.dataset.state || '';
                    if (city && country) {
                        const locationId = state ? `${city}, ${state}, ${country}` : `${city}, ${country}`;
                        const statusResponse = await fetch(`/api/scrape/status/${encodeURIComponent(locationId)}`);
                        const statusData = await statusResponse.json();
                        
                        // If status is error, show error message instead of "no showtimes"
                        if (statusData.status === 'error') {
                            const errorMsg = statusData.message || 'An error occurred while fetching showtimes. Please check your API key configuration.';
                            showErrorState(errorMsg, () => {
                                if (city && country) {
                                    fetchShowtimes(city, country, state);
                                }
                            });
                            return;
                        }
                    }
                } catch (e) {
                    // If status check fails, continue to show empty state
                    console.log('Could not check status:', e);
                }
                showEmptyState('{{ translations.no_showtimes or "No upcoming showtimes found" }}', 'üé¨');
                return;
            }
            
            // Sort showtimes by start_time (ascending - earliest first)
            // This ensures showtimes are displayed in chronological order
            futureShowtimes.sort((a, b) => {
                try {
                    const timeA = a.start_time ? new Date(a.start_time).getTime() : Infinity;
                    const timeB = b.start_time ? new Date(b.start_time).getTime() : Infinity;
                    // Check if dates are valid
                    if (isNaN(timeA)) return 1;  // Invalid dates go to end
                    if (isNaN(timeB)) return -1;
                    return timeA - timeB;
                } catch (e) {
                    return 0;  // Keep order if comparison fails
                }
            });
            
            container.innerHTML = '<div class="showtimes-grid"></div>';
            var grid = container.querySelector('.showtimes-grid');
            
            for (var stIdx = 0; stIdx < futureShowtimes.length; stIdx++) {
                var st = futureShowtimes[stIdx];
                var card = document.createElement('div');
                card.className = 'showtime-card';
                
                // Get movie title in selected language
                var currentLang = '{{ lang }}';
                var movieTitle = 'Unknown Movie';
                if (st.movie && st.movie[currentLang]) {
                    movieTitle = st.movie[currentLang];
                } else if (st.movie && st.movie.en) {
                    movieTitle = st.movie.en;
                } else if (st.movie && st.movie.local) {
                    movieTitle = st.movie.local;
                } else if (st.movie && st.movie.ua) {
                    movieTitle = st.movie.ua;
                } else if (st.movie && st.movie.ru) {
                    movieTitle = st.movie.ru;
                }
                
                // Get movie description in selected language
                var movieDescription = '';
                if (st.movie_description && st.movie_description[currentLang]) {
                    movieDescription = st.movie_description[currentLang];
                } else if (st.movie_description && st.movie_description.en) {
                    movieDescription = st.movie_description.en;
                } else if (st.movie_description && st.movie_description.ua) {
                    movieDescription = st.movie_description.ua;
                } else if (st.movie_description && st.movie_description.ru) {
                    movieDescription = st.movie_description.ru;
                }
                
                // Simplified date formatting - preserve timezone from ISO string
                var startTime;
                try {
                    var date = new Date(st.start_time);
                    if (isNaN(date.getTime())) {
                        startTime = 'Invalid date';
                    } else {
                        // Extract timezone from ISO string if present
                        var tzMatch = st.start_time.match(/([+-]\d{2}):(\d{2})$/);
                        var tzOffset = tzMatch ? tzMatch[0] : null;
                        
                        // Format date in locale-aware way
                        var options = {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        };
                        
                        startTime = date.toLocaleString('{{ lang }}', options);
                        
                        // Add timezone if not UTC
                        if (tzOffset && tzOffset !== '+00:00' && tzOffset !== 'Z') {
                            startTime += ' (UTC' + tzOffset + ')';
                        }
                    }
                } catch (e) {
                    startTime = st.start_time || 'Invalid date';
                }
                var cinemaName = st.cinema_name || st.cinema_id || 'Unknown Cinema';
                // Get translated cinema address (falls back to original if translation not available)
                var cinemaAddress = st.cinema_address_translated || st.cinema_address || '';
                var hallInfo = st.hall ? ' | ' + st.hall : '';
                
                // Movie image with error handling
                var imagePath = st.movie_image_path || '';
                var imageHtml = imagePath 
                    ? '<img src="' + imagePath + '" alt="' + movieTitle + '" class="movie-image" loading="lazy" onerror="this.style.display=\'none\'; this.nextElementSibling.style.display=\'flex\';">'
                    : '';
                var placeholderHtml = '<div class="movie-image-placeholder" style="' + (imagePath ? 'display:none;' : '') + '">üé¨</div>';
                
                // Cinema address display
                var cinemaAddressHtml = cinemaAddress
                    ? '<div class="cinema-address">üìç ' + cinemaAddress + '</div>'
                    : '';
                
                // Build format/language/hall info
                var formatParts = [];
                if (st.format) formatParts.push(st.format);
                if (st.language) formatParts.push(st.language);
                if (hallInfo) formatParts.push(hallInfo);
                var formatInfo = formatParts.join(' | ');
                
                // Build movie description HTML
                var movieDescHtml = movieDescription 
                    ? '<div class="movie-description" style="font-size: 0.9rem; opacity: 0.85; margin: 0.5rem 0; line-height: 1.4; max-height: 3.6em; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;">' + movieDescription + '</div>'
                    : '';
                
                // Build buy button HTML
                var buyBtnHtml = st.cinema_website 
                    ? '<a href="' + st.cinema_website + '" target="_blank" class="buy-btn" aria-label="Buy tickets for ' + movieTitle + '">{{ translations.buy_tickets }}</a>'
                    : '';
                
                card.innerHTML = 
                    '<div class="movie-image-container">' +
                        imageHtml +
                        placeholderHtml +
                    '</div>' +
                    '<div class="showtime-card-content">' +
                        '<h3>' + movieTitle + '</h3>' +
                        movieDescHtml +
                        '<div class="time">' + startTime + '</div>' +
                        '<div class="cinema">' +
                            '<div class="cinema-name">' + cinemaName + '</div>' +
                            cinemaAddressHtml +
                        '</div>' +
                        '<div style="margin-top: auto; padding-top: 1rem;">' +
                            '<div style="margin-bottom: 0.5rem; opacity: 0.8;">' + formatInfo + '</div>' +
                            buyBtnHtml +
                        '</div>' +
                    '</div>';
                
                grid.appendChild(card);
            }
        }
        
        // Filter event listeners
        var filters = [formatFilter, languageFilter];
        for (var fIdx = 0; fIdx < filters.length; fIdx++) {
            var filter = filters[fIdx];
            filter.addEventListener('change', function() {
                if (currentCity) {
                    var locationId = currentCountry ? currentCity + ', ' + currentCountry : currentCity;
                    loadShowtimes(locationId);
                }
            });
        }
        
        // Cleanup polling on page unload
        window.addEventListener('beforeunload', function() {
            if (pollingInterval) clearInterval(pollingInterval);
        });
        
        // Feedback Modal
        var feedbackBtn = document.getElementById('feedback-btn');
        var feedbackModal = document.getElementById('feedback-modal');
        var feedbackClose = document.getElementById('feedback-close');
        var feedbackCancel = document.getElementById('feedback-cancel');
        var feedbackForm = document.getElementById('feedback-form');
        var feedbackMessageDisplay = document.getElementById('feedback-message-display');
        
        function openFeedbackModal() {
            feedbackModal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }
        
        function closeFeedbackModal() {
            feedbackModal.style.display = 'none';
            document.body.style.overflow = 'auto';
            feedbackForm.reset();
            feedbackMessageDisplay.style.display = 'none';
        }
        
        feedbackBtn.addEventListener('click', openFeedbackModal);
        feedbackClose.addEventListener('click', closeFeedbackModal);
        feedbackCancel.addEventListener('click', closeFeedbackModal);
        
        // Close modal when clicking outside
        feedbackModal.addEventListener('click', function(e) {
            if (e.target === feedbackModal) {
                closeFeedbackModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && feedbackModal.style.display === 'block') {
                closeFeedbackModal();
            }
        });
        
        // Handle feedback form submission
        feedbackForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            var submitBtn = feedbackForm.querySelector('.btn-submit');
            var originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            
            var formData = {
                name: document.getElementById('feedback-name').value.trim(),
                email: document.getElementById('feedback-email').value.trim(),
                message: document.getElementById('feedback-message').value.trim()
            };
            
            fetch('/api/feedback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
            }).then(function(response) {
                return response.json().then(function(data) {
                feedbackMessageDisplay.style.display = 'block';
                
                if (data.success) {
                    feedbackMessageDisplay.className = 'success';
                    feedbackMessageDisplay.textContent = '{{ translations.feedback_sent }}';
                    feedbackForm.reset();
                    
                    // Close modal after 2 seconds
                        setTimeout(function() {
                        closeFeedbackModal();
                    }, 2000);
                } else {
                    feedbackMessageDisplay.className = 'error';
                    feedbackMessageDisplay.textContent = data.error || '{{ translations.feedback_error }}';
                }
                    
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                });
            }).catch(function(error) {
                console.error('Feedback error:', error);
                feedbackMessageDisplay.style.display = 'block';
                feedbackMessageDisplay.className = 'error';
                feedbackMessageDisplay.textContent = '{{ translations.feedback_error }}';
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            });
        });
    </script>
    
    <!-- Ko-fi Widget -->
    <!-- 
      If widget appears empty, check browser console for errors.
      Common issues:
      1. Content Security Policy (CSP) blocking - Add to nginx/security headers:
         script-src 'self' 'unsafe-inline' https://storage.ko-fi.com https://*.ko-fi.com;
         frame-src 'self' https://*.ko-fi.com;
         img-src 'self' data: https://*.ko-fi.com;
      2. Ad blockers - Test in incognito mode
      3. Script loading - Check Network tab for 404 errors
    -->
    <script>
      // Initialize Ko-fi widget after script loads
      function initKofiWidget() {
        if (typeof kofiWidgetOverlay !== 'undefined') {
          try {
            kofiWidgetOverlay.draw('oleksandrdon', {
              'type': 'floating-chat',
              'floating-chat.donateButton.text': 'Support Us',
              'floating-chat.donateButton.background-color': '#fcbf47',
              'floating-chat.donateButton.text-color': '#323842'
            });
            console.log('‚úì Ko-fi widget initialized successfully');
          } catch (error) {
            console.error('‚úó Ko-fi widget error:', error);
            console.error('Error details:', error.message, error.stack);
          }
        } else {
          console.error('‚úó kofiWidgetOverlay is not defined. Script may not have loaded correctly.');
        }
      }
      
      // Load Ko-fi script and initialize when ready
      (function() {
        var script = document.createElement('script');
        script.src = 'https://storage.ko-fi.com/cdn/scripts/overlay-widget.js';
        script.async = true;
        script.onload = function() {
          // Wait a tiny bit for the script to fully initialize
          setTimeout(initKofiWidget, 100);
        };
        script.onerror = function() {
          console.error('‚úó Failed to load Ko-fi widget script. Check Network tab for errors.');
        };
        document.head.appendChild(script);
      })();
    </script>
</body>
</html>


